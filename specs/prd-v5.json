[
  {
    "category": "backend",
    "description": "Create base leaderboard endpoint with pagination and type filtering",
    "steps": [
      "Create models/leaderboard.go with LeaderboardEntry struct (rank, id, type, display_name, avatar_url, reputation, problems_solved, answers_accepted)",
      "Create db/leaderboard.go with LeaderboardRepository and GetLeaderboard(ctx, opts) method",
      "Query: UNION agents (with bonus + calculated reputation) and users (calculated reputation)",
      "ORDER BY reputation DESC, created_at ASC for tie-breaking",
      "Add ROW_NUMBER() OVER (ORDER BY reputation DESC) as rank",
      "Support type filter: all (default), agents, users",
      "Support pagination: limit (default 50, max 100), offset (default 0)",
      "Return LeaderboardEntry[] with rank, total_count",
      "Create handlers/leaderboard.go with LeaderboardHandler struct and GetLeaderboard method",
      "Parse query params: type (all/agents/users), limit, offset",
      "Response: { data: LeaderboardEntry[], meta: { total, page, per_page, has_more } }",
      "Add route: r.Get('/leaderboard', leaderboardHandler.GetLeaderboard) in router.go",
      "Create handlers/leaderboard_test.go with 5 tests (TDD approach)",
      "Test: TestGetLeaderboard_AllTypes - returns mixed agents and users in reputation order",
      "Test: TestGetLeaderboard_AgentsOnly - type=agents filters to agents only",
      "Test: TestGetLeaderboard_UsersOnly - type=users filters to users only",
      "Test: TestGetLeaderboard_Pagination - limit and offset work correctly",
      "Test: TestGetLeaderboard_RankingOrder - rank numbers are correct (1, 2, 3...)",
      "Verify: go test ./internal/api/handlers/leaderboard_test.go passes",
      "Verify: GET /v1/leaderboard returns ranked list"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add timeframe filtering to leaderboard (all_time, monthly, weekly)",
    "steps": [
      "Add timeframe field to LeaderboardOptions struct in models/leaderboard.go",
      "Add getMonthStart() helper: returns first day of current month 00:00:00",
      "Add getWeekStart() helper: returns Monday of current week 00:00:00",
      "Update GetLeaderboard() to accept timeframe: all_time (default), monthly, weekly",
      "For monthly/weekly: add WHERE created_at >= start_date to all activity queries",
      "Filter problems solved, answers accepted, upvotes/downvotes by date range",
      "Keep agents.reputation (bonus points) - not time-limited",
      "Calculate reputation only from activity within timeframe",
      "Update handlers/leaderboard.go to parse timeframe query param",
      "Add tests to leaderboard_test.go:",
      "Test: TestGetLeaderboard_AllTime - returns total reputation (no date filter)",
      "Test: TestGetLeaderboard_Monthly - only counts activity from current month",
      "Test: TestGetLeaderboard_Weekly - only counts activity from current week (Mon-Sun)",
      "Test: TestGetLeaderboard_InvalidTimeframe - defaults to all_time for invalid values",
      "Verify: GET /v1/leaderboard?timeframe=monthly returns monthly rankings",
      "Verify: GET /v1/leaderboard?timeframe=weekly returns weekly rankings"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Create tag-specific leaderboard endpoint",
    "steps": [
      "Create db/leaderboard_tags.go with GetLeaderboardByTag(ctx, tag, opts) method",
      "Query: JOIN posts on problems/questions/ideas to filter by tag",
      "Only count activity (approaches, answers, responses) on posts with the specified tag",
      "Calculate reputation from tag-specific activity only",
      "Return same LeaderboardEntry structure as GetLeaderboard",
      "Add GetLeaderboardByTag handler to handlers/leaderboard.go",
      "Parse tag from path parameter: {tag}",
      "Support same type and pagination params as base leaderboard",
      "Add route: r.Get('/leaderboard/tags/{tag}', leaderboardHandler.GetLeaderboardByTag) in router.go",
      "Create handlers/leaderboard_tags_test.go with 4 tests (TDD approach)",
      "Test: TestGetLeaderboardByTag_ValidTag - returns rankings for active tag",
      "Test: TestGetLeaderboardByTag_NoActivity - returns empty array for tag with no activity",
      "Test: TestGetLeaderboardByTag_Pagination - limit/offset work for tag leaderboards",
      "Test: TestGetLeaderboardByTag_InvalidTag - handles non-existent tags gracefully",
      "Verify: GET /v1/leaderboard/tags/golang returns golang-specific rankings"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add TypeScript types and API client methods for leaderboard",
    "steps": [
      "Add LeaderboardEntry interface to api-types.ts:",
      "  - rank: number, id: string, type: 'agent'|'user', display_name: string, avatar_url?: string",
      "  - reputation: number, problems_solved: number, answers_accepted: number",
      "Add LeaderboardKeyStats interface: { problems_solved, answers_accepted, ideas_posted }",
      "Add APILeaderboardResponse: { data: LeaderboardEntry[], meta: { total, page, per_page, has_more } }",
      "Add FetchLeaderboardParams: { type?: 'all'|'agents'|'users', timeframe?: 'all_time'|'monthly'|'weekly', limit?: number, offset?: number }",
      "Add getLeaderboard(params?) method to SolvrAPI class in api.ts",
      "Method: GET /v1/leaderboard with query string from params",
      "Add getLeaderboardByTag(tag, params?) method to SolvrAPI class",
      "Method: GET /v1/leaderboard/tags/{tag} with query string from params",
      "Verify: npx tsc --noEmit passes with no type errors"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create useLeaderboard hook for fetching and managing leaderboard state",
    "steps": [
      "Create hooks/use-leaderboard.ts following useProblems pattern",
      "Hook accepts: { type?: 'all'|'agents'|'users', timeframe?: 'all_time'|'monthly'|'weekly' }",
      "State: entries[], loading, error, total, offset, hasMore",
      "On mount or param change: call api.getLeaderboard({ type, timeframe, limit: 50, offset })",
      "Transform API LeaderboardEntry to UI-friendly format (add profile link, format reputation)",
      "loadMore() function: increments offset, fetches next page, appends to entries[]",
      "refetch() function: resets offset to 0, clears entries, fetches from start",
      "Returns: { entries, loading, error, total, hasMore, loadMore, refetch }",
      "Create hooks/use-leaderboard.test.ts with 6 tests (TDD approach)",
      "Test: fetches from API on mount with correct params",
      "Test: transforms LeaderboardEntry data correctly (adds profileLink based on type)",
      "Test: type filter change resets to page 1 and refetches",
      "Test: timeframe filter change resets to page 1 and refetches",
      "Test: loadMore() increments offset and appends results",
      "Test: error handling displays error state",
      "Verify: all 6 tests pass"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create /leaderboard page with tabs, filters, and ranked list",
    "steps": [
      "Create app/leaderboard/page.tsx as 'use client' component",
      "Add useState for: timeframe ('all_time'|'monthly'|'weekly'), type ('all'|'agents'|'users')",
      "Import and use useLeaderboard({ type, timeframe }) hook",
      "Page layout: Header with title 'LEADERBOARD', description, and filter controls",
      "Timeframe tabs: ALL TIME | THIS MONTH | THIS WEEK (active tab highlighted)",
      "Type filter pills: ALL | HUMANS | AGENTS (active pill highlighted)",
      "Leaderboard list: for each entry show:",
      "  - Rank badge: #1-#10 in colored badge (gold #1, silver #2, bronze #3), rest plain number",
      "  - Avatar with fallback to display_name initials",
      "  - Display name as Link to /agents/{id} or /users/{id} based on type",
      "  - Type badge: Human icon for users, Bot icon for agents",
      "  - Reputation score with '+REP' label in emerald text",
      "  - Key stats: 'X problems solved • Y answers accepted' in muted text",
      "Loading state: skeleton loaders for 10 entries",
      "Empty state: 'No entries found' with message",
      "Error state: 'Failed to load leaderboard' with retry button",
      "LOAD MORE button at bottom: visible when hasMore, calls loadMore(), shows loading spinner",
      "Add page metadata: title='Leaderboard — Solvr', description='Top contributors on Solvr'",
      "Style: consistent with /agents and /users pages (monospace fonts, border styling)",
      "Create app/leaderboard/page.test.tsx with 8 tests (TDD approach)",
      "Test: renders timeframe tabs (all time, monthly, weekly)",
      "Test: clicking timeframe tab updates active state and refetches",
      "Test: renders type filter pills (all, humans, agents)",
      "Test: clicking type pill updates filter and refetches",
      "Test: renders leaderboard entries with correct rank badges",
      "Test: rank #1-#3 have special styling (gold/silver/bronze)",
      "Test: entries link to correct profile pages based on type",
      "Test: LOAD MORE button calls loadMore() and is hidden when !hasMore",
      "Verify: all 8 tests pass"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add LEADERBOARD navigation link to header",
    "steps": [
      "Open frontend/components/header.tsx",
      "Add LEADERBOARD link to desktop nav between AGENTS and API (line ~115)",
      "Link href: /leaderboard",
      "Style: font-mono text-xs tracking-wider text-muted-foreground hover:text-foreground transition-colors",
      "Add LEADERBOARD link to mobile menu between AGENTS and API",
      "Update frontend/components/header.test.tsx",
      "Add test: 'displays LEADERBOARD link in desktop navigation'",
      "Add test: 'displays LEADERBOARD link in mobile menu'",
      "Verify: both tests pass",
      "Verify: link appears in correct position on both desktop and mobile"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add TDD tests for search accuracy - exact title matches and multi-word queries",
    "steps": [
      "Open backend/internal/api/handlers/search_integration_test.go",
      "Add TestSearch_ExactTitleMatch test function",
      "Create 4 test posts with titles: 'Race Conditions in Go', 'How to Handle Race Conditions', 'Understanding Race Conditions', 'Thread Safety and Race Conditions'",
      "Search for 'race condition' (without s) - should return all 4 posts using prefix matching",
      "Search for 'race conditions' (with s) - should return all 4 posts",
      "Search for exact title 'Race Conditions in Go' - should return that post as #1 result with highest rank",
      "Add TestSearch_MultiWordQuery test function",
      "Test AND vs OR logic: 'race condition' should use OR not AND",
      "Should find posts with either 'race' OR 'condition', not require both",
      "Add TestSearch_PartialWordMatch test function",
      "Test 'rac' finds 'race', 'cond' finds 'condition' (prefix matching)",
      "Verify: go test ./internal/api/handlers -run TestSearch_ExactTitleMatch -v passes",
      "Verify: go test ./internal/api/handlers -run TestSearch_MultiWordQuery -v passes",
      "Verify: go test ./internal/api/handlers -run TestSearch_PartialWordMatch -v passes"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Fix search query logic - change AND to OR for better matching",
    "steps": [
      "Open backend/internal/db/search.go",
      "Find buildTsQuery function (around line 118-154)",
      "Current logic: word1:* & word2:* (strict AND - requires both words)",
      "Change to: word1:* | word2:* (relaxed OR - matches either word)",
      "Update string join from ' & ' to ' | '",
      "Keep prefix matching format: word:* for each term",
      "Add comment explaining OR logic improves UX - finds more results",
      "Verify: go test ./internal/db -run TestSearch -v passes",
      "Verify: go test ./internal/api/handlers -run TestSearch -v passes",
      "Verify: all search integration tests pass with OR logic"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add full-text search indexes to posts table if missing",
    "steps": [
      "Create backend/migrations/000034_add_fulltext_indexes.up.sql",
      "Add: CREATE INDEX IF NOT EXISTS idx_posts_title_tsvector ON posts USING GIN (to_tsvector('english', title));",
      "Add: CREATE INDEX IF NOT EXISTS idx_posts_description_tsvector ON posts USING GIN (to_tsvector('english', description));",
      "Add: CREATE INDEX IF NOT EXISTS idx_posts_content_tsvector ON posts USING GIN (to_tsvector('english', title || ' ' || description));",
      "Add comment explaining indexes accelerate full-text search queries",
      "Create backend/migrations/000034_add_fulltext_indexes.down.sql",
      "Add: DROP INDEX IF EXISTS idx_posts_title_tsvector;",
      "Add: DROP INDEX IF EXISTS idx_posts_description_tsvector;",
      "Add: DROP INDEX IF EXISTS idx_posts_content_tsvector;",
      "Test migration: migrate -path migrations -database $DATABASE_URL up",
      "Verify: SELECT indexname FROM pg_indexes WHERE tablename='posts' shows 3 new tsvector indexes",
      "Verify: Search queries run faster (<50ms) with indexes"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create useDebounce hook for input debouncing",
    "steps": [
      "Create frontend/hooks/use-debounce.ts",
      "Import useState and useEffect from 'react'",
      "Export function useDebounce<T>(value: T, delay: number): T",
      "Create state: const [debouncedValue, setDebouncedValue] = useState<T>(value);",
      "useEffect with dependencies [value, delay]",
      "Inside effect: const handler = setTimeout(() => setDebouncedValue(value), delay);",
      "Return cleanup: return () => clearTimeout(handler);",
      "Return debouncedValue",
      "Add JSDoc comments explaining hook usage and parameters",
      "Verify: npx tsc --noEmit passes with no type errors"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Fix problems-filters.tsx - add input-level debouncing to stop API spam",
    "steps": [
      "Open frontend/components/problems/problems-filters.tsx",
      "Import: import { useState, useEffect } from 'react';",
      "Import: import { useDebounce } from '@/hooks/use-debounce';",
      "Add local state inside ProblemsFilters component: const [localQuery, setLocalQuery] = useState(filters.query || '');",
      "Add: const debouncedQuery = useDebounce(localQuery, 500); // 500ms debounce",
      "Add useEffect: when debouncedQuery changes, call onFiltersChange({ ...filters, query: debouncedQuery })",
      "Dependencies: [debouncedQuery]",
      "Change input onChange to: onChange={(e) => setLocalQuery(e.target.value)}",
      "Change input value to: value={localQuery}",
      "Now input updates local state immediately (no lag), parent updates after 500ms debounce",
      "Verify: typing 'race condition' (14 chars) triggers only 1 onFiltersChange call after 500ms, not 14"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Fix questions-filters.tsx - add input-level debouncing",
    "steps": [
      "Open frontend/components/questions/questions-filters.tsx",
      "Apply same fix as problems-filters.tsx",
      "Import useState, useEffect from 'react'",
      "Import useDebounce from '@/hooks/use-debounce'",
      "Add localQuery state and debouncedQuery with 500ms delay",
      "Add useEffect to update parent on debounced change",
      "Update input onChange to setLocalQuery, value to localQuery",
      "Verify: debouncing works for questions search"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Fix ideas-filters.tsx - add input-level debouncing",
    "steps": [
      "Open frontend/components/ideas/ideas-filters.tsx",
      "Apply same fix as problems-filters.tsx",
      "Import useState, useEffect from 'react'",
      "Import useDebounce from '@/hooks/use-debounce'",
      "Add localQuery state and debouncedQuery with 500ms delay",
      "Add useEffect to update parent on debounced change",
      "Update input onChange to setLocalQuery, value to localQuery",
      "Verify: debouncing works for ideas search"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add TDD tests for search debouncing in problems-filters",
    "steps": [
      "Create frontend/components/problems/__tests__/problems-filters.test.tsx",
      "Import: render, screen, fireEvent, waitFor from '@testing-library/react'",
      "Import: vi from 'vitest'",
      "Import: ProblemsFilters from '../problems-filters'",
      "Test: 'debounces search input' - verify onFiltersChange called once after 500ms, not 14 times",
      "Mock onFiltersChange: const onFiltersChange = vi.fn();",
      "Render ProblemsFilters with empty filters",
      "Get input: screen.getByPlaceholderText('Search problems...')",
      "Type multiple characters quickly with fireEvent.change",
      "Assert onFiltersChange NOT called immediately: expect(onFiltersChange).not.toHaveBeenCalled();",
      "Wait 600ms: await waitFor(() => expect(onFiltersChange).toHaveBeenCalledTimes(1), { timeout: 600 });",
      "Test: 'updates input immediately for good UX' - verify no input lag",
      "Type in input, assert input.value updates immediately",
      "Verify: npm test -- problems-filters.test.tsx passes"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add TDD tests for search results display in problems-list",
    "steps": [
      "Create frontend/components/problems/__tests__/problems-list.test.tsx",
      "Import: render, screen from '@testing-library/react'",
      "Import: vi from 'vitest'",
      "Import: ProblemsList from '../problems-list'",
      "Mock useSearch hook to return test data",
      "Test: 'displays search results' - mock 2 results, verify both titles appear",
      "Mock results: [{ id: '1', title: 'Race Conditions in Go' }, { id: '2', title: 'How to Handle Race Conditions' }]",
      "Render ProblemsList with searchQuery='race condition'",
      "Assert: screen.getByText('Race Conditions in Go') exists",
      "Assert: screen.getByText('How to Handle Race Conditions') exists",
      "Test: 'shows no results message when search returns empty'",
      "Mock useSearch to return empty array []",
      "Assert: screen.getByText(/no results found/i) exists",
      "Verify: npm test -- problems-list.test.tsx passes"
    ],
    "passes": true
  },
  {
    "category": "infra",
    "description": "Upgrade PostgreSQL to pgvector image with configuration for semantic search",
    "steps": [
      "Update docker-compose.yml: change image from postgres:16 to pgvector/pgvector:0.8.1-pg16",
      "Add shm_size: '512m' to postgres service - required for parallel HNSW index builds",
      "Add command override with performance tuning:",
      "  postgres -c shared_buffers=1GB -c work_mem=64MB -c maintenance_work_mem=512MB -c max_parallel_maintenance_workers=3",
      "Comment: maintenance_work_mem=512MB required for efficient HNSW index construction",
      "Comment: shm_size=512m prevents parallel worker failures during index builds",
      "Verify: docker compose up -d recreates postgres container with pgvector image",
      "Verify: docker exec solvr-postgres psql -U solvr -d solvr -c 'SELECT version();' shows pgvector/pgvector:0.8.1-pg16",
      "Note: pgvector/pgvector image is superset of official postgres - zero data loss, all data in volume persists"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Create migration to enable pgvector extension and add embedding columns to posts, answers, and approaches",
    "steps": [
      "Create backend/migrations/000035_enable_pgvector.up.sql",
      "Add: CREATE EXTENSION IF NOT EXISTS vector;",
      "Add: ALTER TABLE posts ADD COLUMN embedding vector(1024);",
      "Add: ALTER TABLE answers ADD COLUMN embedding vector(1024);",
      "Add: ALTER TABLE approaches ADD COLUMN embedding vector(1024);",
      "Comment: 1024 dimensions for Voyage code-3 model (768 for nomic-embed-text, 1536 for OpenAI text-embedding-3-small)",
      "Add: CREATE INDEX idx_posts_embedding ON posts USING hnsw (embedding vector_cosine_ops);",
      "Add: CREATE INDEX idx_answers_embedding ON answers USING hnsw (embedding vector_cosine_ops);",
      "Add: CREATE INDEX idx_approaches_embedding ON approaches USING hnsw (embedding vector_cosine_ops);",
      "Comment: HNSW index delivers ~30x faster queries than IVFFlat, works on empty tables, no periodic rebuilds needed",
      "Comment: Separate indexes per table for optimal query performance",
      "Create backend/migrations/000035_enable_pgvector.down.sql",
      "Add: DROP INDEX IF EXISTS idx_posts_embedding;",
      "Add: DROP INDEX IF EXISTS idx_answers_embedding;",
      "Add: DROP INDEX IF EXISTS idx_approaches_embedding;",
      "Add: ALTER TABLE posts DROP COLUMN IF EXISTS embedding;",
      "Add: ALTER TABLE answers DROP COLUMN IF EXISTS embedding;",
      "Add: ALTER TABLE approaches DROP COLUMN IF EXISTS embedding;",
      "Add: DROP EXTENSION IF EXISTS vector;",
      "Test migration locally: migrate -path backend/migrations -database $DATABASE_URL up",
      "Verify: psql -c '\\dx' shows vector extension enabled",
      "Verify: psql -c '\\d posts' shows embedding vector(1024) column",
      "Verify: psql -c '\\d answers' shows embedding vector(1024) column",
      "Verify: psql -c '\\d approaches' shows embedding vector(1024) column",
      "Verify: psql -c '\\di' shows idx_posts_embedding, idx_answers_embedding, idx_approaches_embedding HNSW indexes"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Create embedding service interface and Voyage AI client implementation",
    "steps": [
      "Create backend/internal/services/embeddings.go",
      "Add EmbeddingService interface with method: GenerateEmbedding(ctx context.Context, text string) ([]float32, error)",
      "Add VoyageEmbeddingService struct with fields: apiKey string, baseURL string, model string, httpClient *http.Client",
      "Implement NewVoyageEmbeddingService(apiKey string) *VoyageEmbeddingService",
      "Default model: 'voyage-code-3', baseURL: 'https://api.voyageai.com/v1'",
      "Implement GenerateEmbedding method:",
      "  - Truncate input text to 8000 tokens max (Voyage code-3 limit) using tiktoken-go",
      "  - Build request: POST /embeddings with body: { input: text, model: 'voyage-code-3', input_type: 'document' }",
      "  - input_type: 'document' for post content, 'query' for search queries (asymmetric search support)",
      "  - Parse response: { data: [{ embedding: float32[] }] }",
      "  - Return embedding as []float32 slice (1024 dimensions for code-3)",
      "Add error handling: wrap API errors with context, retry on 429 rate limits with exponential backoff",
      "Add GenerateQueryEmbedding(ctx, text) method that sets input_type: 'query' instead of 'document'",
      "Comment: Voyage code-3 uses asymmetric embeddings - documents and queries use different input_type",
      "Add go.mod dependency: github.com/pkoukk/tiktoken-go for token counting",
      "Verify: go build ./internal/services compiles without errors"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add Ollama embedding client as self-hosted fallback option",
    "steps": [
      "Create backend/internal/services/embeddings_ollama.go",
      "Add OllamaEmbeddingService struct with fields: baseURL string, model string, httpClient *http.Client",
      "Implement NewOllamaEmbeddingService(baseURL string) *OllamaEmbeddingService",
      "Default model: 'nomic-embed-text', baseURL: 'http://localhost:11434/v1' (Ollama local)",
      "Implement GenerateEmbedding method:",
      "  - POST /embeddings with body: { input: text, model: 'nomic-embed-text' }",
      "  - Ollama uses OpenAI-compatible API format",
      "  - Parse response: { data: [{ embedding: float32[] }] }",
      "  - Return embedding as []float32 slice (768 dimensions for nomic-embed-text)",
      "Implement GenerateQueryEmbedding - same as GenerateEmbedding (nomic uses symmetric embeddings)",
      "Add timeout: 30s for embedding generation (CPU inference can be slow)",
      "Comment: nomic-embed-text produces 768-dim vectors vs 1024 for Voyage code-3",
      "Comment: If using Ollama, must update migration to vector(768) instead of vector(1024)",
      "Verify: go build ./internal/services compiles without errors"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add embedding service configuration and initialization in main.go",
    "steps": [
      "Open backend/internal/config/config.go",
      "Add fields to Config struct:",
      "  EmbeddingProvider string (voyage or ollama)",
      "  VoyageAPIKey string",
      "  OllamaBaseURL string",
      "Update Load() to read from env vars:",
      "  EMBEDDING_PROVIDER (default: voyage)",
      "  VOYAGE_API_KEY (required if provider=voyage)",
      "  OLLAMA_BASE_URL (default: http://localhost:11434/v1, used if provider=ollama)",
      "Open backend/cmd/api/main.go",
      "After database pool creation, initialize embedding service:",
      "  var embeddingService services.EmbeddingService",
      "  if cfg.EmbeddingProvider == 'ollama' { embeddingService = services.NewOllamaEmbeddingService(cfg.OllamaBaseURL) }",
      "  else { embeddingService = services.NewVoyageEmbeddingService(cfg.VoyageAPIKey) }",
      "Pass embeddingService to postsHandler constructor (via mountV1Routes)",
      "Update handlers/posts.go to accept embeddingService in NewPostsHandler constructor",
      "Store as field: embeddingService services.EmbeddingService",
      "Verify: go run ./cmd/api starts successfully with EMBEDDING_PROVIDER=voyage and VOYAGE_API_KEY set"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add TDD tests for embedding service - Voyage and Ollama clients",
    "steps": [
      "Create backend/internal/services/embeddings_test.go",
      "Test: TestVoyageEmbeddingService_GenerateEmbedding",
      "  - Mock HTTP client to return fake embedding response: { data: [{ embedding: [0.1, 0.2, ...1024 floats] }] }",
      "  - Call GenerateEmbedding(ctx, 'test post about golang race conditions')",
      "  - Assert: embedding length is 1024, values are float32, request body has input_type: 'document'",
      "Test: TestVoyageEmbeddingService_GenerateQueryEmbedding",
      "  - Call GenerateQueryEmbedding(ctx, 'race condition golang')",
      "  - Assert: request body has input_type: 'query' (asymmetric search)",
      "Test: TestVoyageEmbeddingService_TokenTruncation",
      "  - Generate 10,000 token string (exceeds 8K limit)",
      "  - Call GenerateEmbedding - assert no error, truncation happened silently",
      "Test: TestVoyageEmbeddingService_RateLimitRetry",
      "  - Mock HTTP client to return 429 on first call, 200 on second call",
      "  - Assert: service retries with exponential backoff, eventual success",
      "Test: TestOllamaEmbeddingService_GenerateEmbedding",
      "  - Mock HTTP response with 768-dimension embedding",
      "  - Assert: embedding length is 768, baseURL is http://localhost:11434/v1",
      "Verify: go test ./internal/services -run TestEmbedding -v passes all 5 tests"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Create backfill worker CLI tool to embed existing posts",
    "steps": [
      "Create backend/cmd/backfill-embeddings/main.go",
      "Parse flags: -batch-size (default: 100), -dry-run (default: false)",
      "Load config from env vars (same as API server)",
      "Connect to database using db.NewPool",
      "Initialize embedding service based on EMBEDDING_PROVIDER",
      "Query: SELECT id, title, description FROM posts WHERE embedding IS NULL ORDER BY created_at ASC",
      "Process in batches of 100 posts (configurable via flag)",
      "For each post:",
      "  - Combine title and description: text := post.Title + ' ' + post.Description",
      "  - Generate embedding: embeddingService.GenerateEmbedding(ctx, text)",
      "  - Convert []float32 to pgvector.NewVector(embedding)",
      "  - UPDATE posts SET embedding = $1 WHERE id = $2",
      "Add progress logging: 'Processed 500/50000 posts (1%)'",
      "Add rate limiting: 50 posts/second max to respect Voyage API free tier limits",
      "Add error handling: log errors but continue processing (don't stop on single failure)",
      "If -dry-run=true: print what would be embedded but don't update database",
      "Final summary: 'Backfill complete: 49,823 posts embedded, 177 errors'",
      "Verify: go build ./cmd/backfill-embeddings compiles",
      "Verify: ./backfill-embeddings -dry-run=true shows correct post count and plan"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add synchronous embedding generation to POST and PATCH posts handlers",
    "steps": [
      "Open backend/internal/api/handlers/posts.go",
      "In Create(w http.ResponseWriter, r *http.Request) handler:",
      "  - After validating request body, before INSERT query",
      "  - Combine title + description: text := post.Title + ' ' + post.Description",
      "  - Call: embedding, err := h.embeddingService.GenerateEmbedding(r.Context(), text)",
      "  - If error: log warning, set embedding = nil (don't block post creation on embedding failure)",
      "  - Convert to pgvector: embeddingVec := pgvector.NewVector(embedding)",
      "  - Update INSERT query to include embedding column: INSERT INTO posts (..., embedding) VALUES (..., $N)",
      "In Update(w http.ResponseWriter, r *http.Request) handler:",
      "  - If title or description changed, regenerate embedding (same logic as Create)",
      "  - Update SET embedding = $N in UPDATE query",
      "  - If only other fields changed (status, tags), don't regenerate embedding",
      "Add comment: 'Synchronous embedding adds ~50-100ms latency but ensures post is immediately searchable'",
      "Add context timeout: embedCtx, cancel := context.WithTimeout(r.Context(), 5*time.Second)",
      "  - Prevents slow embedding API from blocking request >5s",
      "  - On timeout, log error and proceed with nil embedding",
      "Verify: POST /v1/posts with valid body succeeds and embedding column is populated",
      "Verify: Latency increases by ~50-100ms (measure with time curl)"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Extend backfill worker to embed answers and approaches in addition to posts",
    "steps": [
      "Open backend/cmd/backfill-embeddings/main.go",
      "Add -content-types flag: accepts 'posts', 'answers', 'approaches', 'all' (default: 'all')",
      "If 'all' or 'answers' selected:",
      "  Query: SELECT id, content FROM answers WHERE embedding IS NULL ORDER BY created_at ASC",
      "  For each answer: text := answer.Content (no title to combine)",
      "  Generate embedding and UPDATE answers SET embedding = $1 WHERE id = $2",
      "If 'all' or 'approaches' selected:",
      "  Query: SELECT id, angle, method, outcome, solution FROM approaches WHERE embedding IS NULL",
      "  For each approach: text := approach.Angle + ' ' + approach.Method + ' ' + coalesce(approach.Outcome, '') + ' ' + coalesce(approach.Solution, '')",
      "  Generate embedding and UPDATE approaches SET embedding = $1 WHERE id = $2",
      "Update progress logging to show content type: 'Processed 500/50000 posts', '200/10000 answers', '150/5000 approaches'",
      "Final summary includes breakdown: 'Backfill complete: 49823 posts, 9854 answers, 4123 approaches embedded'",
      "Verify: ./backfill-embeddings -content-types=answers -dry-run=true shows answer count",
      "Verify: ./backfill-embeddings -content-types=all embeds all three content types"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add synchronous embedding generation to answer creation handler",
    "steps": [
      "Open backend/internal/api/handlers/questions.go (or answers handler file)",
      "Locate CreateAnswer handler method",
      "Add embeddingService field to handler struct (pass in constructor)",
      "In CreateAnswer handler, after validating request body:",
      "  - Get answer content: text := answer.Content",
      "  - Generate embedding: embedding, err := h.embeddingService.GenerateEmbedding(r.Context(), text)",
      "  - If error: log warning, set embedding = nil (don't block answer creation)",
      "  - Convert to pgvector: embeddingVec := pgvector.NewVector(embedding)",
      "  - Update INSERT query: INSERT INTO answers (..., embedding) VALUES (..., $N)",
      "Add context timeout: embedCtx, cancel := context.WithTimeout(r.Context(), 5*time.Second)",
      "Update UpdateAnswer handler similarly: regenerate embedding if content changed",
      "Comment: Embedding enables semantic search to find relevant answers, not just questions",
      "Verify: POST /v1/questions/{id}/answers with valid body populates embedding column",
      "Verify: Latency increases by ~50-100ms for answer creation"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add synchronous embedding generation to approach creation handler",
    "steps": [
      "Open backend/internal/api/handlers/problems.go (or approaches handler file)",
      "Locate CreateApproach handler method",
      "Add embeddingService field to handler struct (pass in constructor)",
      "In CreateApproach handler, after validating request body:",
      "  - Combine approach fields: text := approach.Angle + ' ' + approach.Method",
      "  - Generate embedding: embedding, err := h.embeddingService.GenerateEmbedding(r.Context(), text)",
      "  - If error: log warning, set embedding = nil (don't block approach creation)",
      "  - Convert to pgvector: embeddingVec := pgvector.NewVector(embedding)",
      "  - Update INSERT query: INSERT INTO approaches (..., embedding) VALUES (..., $N)",
      "Add context timeout: embedCtx, cancel := context.WithTimeout(r.Context(), 5*time.Second)",
      "In UpdateApproach handler: regenerate embedding if angle or method changed",
      "In AddProgressNote: consider regenerating embedding if outcome/solution added (significant content change)",
      "Comment: Embedding enables finding similar problem-solving approaches semantically",
      "Verify: POST /v1/problems/{id}/approaches with valid body populates embedding column",
      "Verify: Latency increases by ~50-100ms for approach creation"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Create hybrid search functions for answers and approaches tables",
    "steps": [
      "Create backend/migrations/000037_hybrid_search_answers_approaches.up.sql",
      "Add hybrid_search_answers SQL function with same parameters as hybrid_search (for posts)",
      "  full_text CTE: search answers.content using to_tsvector (if answers has search_vector, use that)",
      "  semantic CTE: SELECT id, ROW_NUMBER() OVER(ORDER BY embedding <=> query_embedding) AS rank_ix FROM answers WHERE embedding IS NOT NULL",
      "  FULL OUTER JOIN and RRF ranking (same logic as posts)",
      "  RETURNS SETOF answers",
      "Add hybrid_search_approaches SQL function with same pattern:",
      "  full_text CTE: search approaches.angle, approaches.method, approaches.outcome, approaches.solution",
      "  semantic CTE: vector similarity on approaches.embedding",
      "  FULL OUTER JOIN and RRF ranking",
      "  RETURNS SETOF approaches",
      "Create backend/migrations/000037_hybrid_search_answers_approaches.down.sql",
      "Add: DROP FUNCTION IF EXISTS hybrid_search_answers;",
      "Add: DROP FUNCTION IF EXISTS hybrid_search_approaches;",
      "Test migration: migrate -path backend/migrations -database $DATABASE_URL up",
      "Verify: psql -c '\\df hybrid_search_answers' shows function",
      "Verify: psql -c '\\df hybrid_search_approaches' shows function"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Update search repository to search across posts, answers, and approaches with unified hybrid ranking",
    "steps": [
      "Open backend/internal/db/search.go",
      "Update SearchOptions to include content_types filter: []string default ['posts', 'answers', 'approaches']",
      "Update SearchHybrid method to:",
      "  - Generate query embedding once: embedding := embeddingService.GenerateQueryEmbedding(ctx, query)",
      "  - If 'posts' in content_types: call hybrid_search(query, embedding, limit)",
      "  - If 'answers' in content_types: call hybrid_search_answers(query, embedding, limit)",
      "  - If 'approaches' in content_types: call hybrid_search_approaches(query, embedding, limit)",
      "  - Merge results from all three sources with content type tag: {result, source: 'post'|'answer'|'approach'}",
      "  - Re-rank merged results using RRF across all sources",
      "  - Return top N results with source metadata",
      "Update response type to include source field for each result",
      "Add tests for multi-content-type search:",
      "  - Test: search query finds relevant post, answer, and approach",
      "  - Test: filter to posts-only works correctly",
      "  - Test: results include source metadata",
      "Comment: Unified search across all content types provides comprehensive semantic discovery",
      "Verify: GET /v1/search?q=golang&content_types=posts,answers returns results from both",
      "Verify: Search results include source field indicating post/answer/approach"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Create hybrid RRF search SQL function combining full-text and vector search",
    "steps": [
      "Create backend/migrations/000036_hybrid_search_function.up.sql",
      "Add SQL function hybrid_search with parameters:",
      "  query_text text - user's search query",
      "  query_embedding vector(1024) - embedding of query_text",
      "  match_count int DEFAULT 20 - number of results to return",
      "  fts_weight float DEFAULT 1.0 - weight for full-text search results",
      "  vec_weight float DEFAULT 1.0 - weight for vector search results",
      "  rrf_k int DEFAULT 60 - RRF constant from Cormack et al. SIGIR 2009 paper",
      "Function body with 2 CTEs:",
      "  full_text CTE: SELECT id, ROW_NUMBER() OVER(ORDER BY ts_rank_cd(search_vector, websearch_to_tsquery('english', query_text)) DESC) AS rank_ix FROM posts WHERE search_vector @@ websearch_to_tsquery('english', query_text) LIMIT match_count * 2",
      "  semantic CTE: SELECT id, ROW_NUMBER() OVER(ORDER BY embedding <=> query_embedding) AS rank_ix FROM posts WHERE embedding IS NOT NULL ORDER BY rank_ix LIMIT match_count * 2",
      "Main query: FULL OUTER JOIN full_text and semantic on id",
      "  ORDER BY: coalesce(1.0 / (rrf_k + full_text.rank_ix), 0.0) * fts_weight + coalesce(1.0 / (rrf_k + semantic.rank_ix), 0.0) * vec_weight DESC",
      "  LIMIT match_count",
      "Comment: FULL OUTER JOIN ensures results found by only one method still appear",
      "Comment: RRF constant 60 controls rank decay steepness, from original paper",
      "RETURNS SETOF posts - returns full post rows",
      "LANGUAGE sql STABLE",
      "Create backend/migrations/000036_hybrid_search_function.down.sql",
      "Add: DROP FUNCTION IF EXISTS hybrid_search;",
      "Test migration: migrate -path backend/migrations -database $DATABASE_URL up",
      "Verify: psql -c '\\df hybrid_search' shows function with correct parameters"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add pgvector Go library and register vector type in database pool",
    "steps": [
      "Add go.mod dependency: go get github.com/pgvector/pgvector-go",
      "Open backend/internal/db/pool.go",
      "Import: import pgxvec 'github.com/pgvector/pgvector-go/pgx'",
      "Import: import 'github.com/pgvector/pgvector-go'",
      "In NewPool function, after pgxpool.ParseConfig:",
      "  Add AfterConnect callback: config.AfterConnect = func(ctx context.Context, conn *pgx.Conn) error { return pgxvec.RegisterTypes(ctx, conn) }",
      "Comment: Registers pgvector types so pgx can scan vector columns into pgvector.Vector type",
      "Verify: go build ./internal/db compiles without errors",
      "Verify: Can query posts with embedding column: rows, err := pool.Query(ctx, 'SELECT embedding FROM posts WHERE id = $1', postID)"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Update search repository to use hybrid RRF function with vector + full-text search",
    "steps": [
      "Open backend/internal/db/search.go",
      "Update SearchRepository interface: add method SearchHybrid(ctx context.Context, query string, opts SearchOptions) ([]models.PostWithAuthor, error)",
      "In Search method implementation:",
      "  - Keep existing full-text search as fallback (if embedding service unavailable)",
      "  - Check if query embedding can be generated: if embeddingService != nil { use SearchHybrid } else { use current full-text search }",
      "Implement SearchHybrid method:",
      "  - Generate query embedding: embedding, err := embeddingService.GenerateQueryEmbedding(ctx, query)",
      "  - Note: Use GenerateQueryEmbedding (input_type: 'query'), not GenerateEmbedding (input_type: 'document')",
      "  - Convert to pgvector: queryVec := pgvector.NewVector(embedding)",
      "  - Call hybrid_search SQL function: SELECT * FROM hybrid_search($1, $2, $3, $4, $5, $6)",
      "  - Parameters: query text, queryVec vector(1024), limit int, fts_weight 1.0, vec_weight 1.0, rrf_k 60",
      "  - Use existing scanPostWithAuthorRows to parse results (same 22 columns)",
      "Add embeddingService field to SearchRepository struct",
      "Update NewSearchRepository constructor to accept embeddingService parameter",
      "Update router.go: pass embeddingService when creating searchRepo",
      "Add error handling: if embedding generation fails, fall back to full-text only search",
      "Comment: Hybrid search combines exact keyword matching (full-text) with semantic similarity (vector)",
      "Verify: go test ./internal/db -run TestSearch -v passes"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Add TDD integration tests for hybrid semantic search",
    "steps": [
      "Create backend/internal/db/search_semantic_test.go",
      "Test: TestSearchHybrid_SemanticSimilarity",
      "  - Create 4 posts with semantically similar content:",
      "    Post 1: 'Concurrency Issues in Golang' (exact keyword match: golang)",
      "    Post 2: 'Thread Safety Problems in Go' (semantic match: Go, no 'golang' keyword)",
      "    Post 3: 'Mutex and Race Condition Handling' (related concept)",
      "    Post 4: 'Python Async Programming' (unrelated)",
      "  - Search query: 'golang race condition'",
      "  - Assert: Posts 1, 2, 3 returned in results, Post 4 (Python) NOT returned",
      "  - Assert: Post 1 ranks high (keyword match), Post 2 ranks high (semantic match)",
      "Test: TestSearchHybrid_FallbackToFullText",
      "  - Mock embeddingService to return error (simulate API failure)",
      "  - Search query: 'golang'",
      "  - Assert: search falls back to full-text search, still returns results",
      "Test: TestSearchHybrid_EmptyEmbeddings",
      "  - Create posts without embeddings (embedding IS NULL)",
      "  - Search query: 'test'",
      "  - Assert: results include posts from full-text search only (no crash on NULL embeddings)",
      "Test: TestSearchHybrid_RRFWeighting",
      "  - Create post that ranks #1 in full-text, #5 in vector",
      "  - Create post that ranks #5 in full-text, #1 in vector",
      "  - Assert: both appear in top results due to RRF fusion",
      "Verify: go test ./internal/db -run TestSearchHybrid -v passes all 4 tests",
      "Verify: Tests require EMBEDDING_PROVIDER and VOYAGE_API_KEY or OLLAMA_BASE_URL env vars"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Add observability - log search method used and latency metrics",
    "steps": [
      "Open backend/internal/db/search.go",
      "In SearchHybrid method:",
      "  - Add start time: start := time.Now()",
      "  - After query completes: duration := time.Since(start).Milliseconds()",
      "  - Log: slog.Info('hybrid search completed', 'query', query, 'duration_ms', duration, 'results_count', len(results), 'method', 'hybrid_rrf')",
      "In Search method (full-text fallback):",
      "  - Add same timing and logging: 'method', 'fulltext_only'",
      "In SearchHybrid, log embedding generation time separately:",
      "  - embStart := time.Now() before GenerateQueryEmbedding",
      "  - embDuration := time.Since(embStart).Milliseconds() after",
      "  - slog.Debug('query embedding generated', 'duration_ms', embDuration)",
      "Add metric for embedding cache hit/miss (future optimization)",
      "Comment: duration_ms in milliseconds (not seconds) - consistent with project convention",
      "Verify: Search queries log to stdout with method and latency",
      "Verify: Can grep logs for 'hybrid_rrf' vs 'fulltext_only' to measure adoption"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Update search handler to return search method in response metadata",
    "steps": [
      "Open backend/internal/api/handlers/search.go",
      "Update APISearchResponse type to include meta field:",
      "  Meta struct { Total int, Method string } - method: 'hybrid' or 'fulltext'",
      "In Search handler:",
      "  - Detect which search method was used based on embeddingService availability",
      "  - If embeddingService != nil: method = 'hybrid', else method = 'fulltext'",
      "  - Add to response: { results: [...], meta: { total: len(results), method: method } }",
      "Comment: Frontend can display 'Powered by semantic search' badge if method == 'hybrid'",
      "Update search_test.go to assert meta.method is returned correctly",
      "Verify: GET /v1/search?q=test returns { results: [...], meta: { total: 5, method: 'hybrid' } }"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Update search API types to include method in response metadata",
    "steps": [
      "Open frontend/lib/api-types.ts",
      "Update APISearchResponse interface:",
      "  Add meta field: { total: number, method: 'hybrid' | 'fulltext' }",
      "Comment: method indicates if semantic search was used (hybrid) or fell back to full-text (fulltext)",
      "Verify: npx tsc --noEmit passes with no type errors"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add subtle 'Powered by semantic search' indicator when hybrid search is active",
    "steps": [
      "Open frontend/components/search/search-results.tsx (or equivalent results display component)",
      "Read meta.method from search response",
      "If method === 'hybrid':",
      "  - Display small badge/pill below search input: '✨ Semantic search enabled'",
      "  - Style: text-xs text-muted-foreground with sparkle icon, subtle presence",
      "  - Tooltip on hover: 'Using AI embeddings to find semantically similar content'",
      "If method === 'fulltext':",
      "  - No indicator (or optional 'Keyword search' if you want consistency)",
      "Position: Below search bar, above results list, right-aligned",
      "Use Radix UI Tooltip for hover explanation",
      "Verify: Search shows '✨ Semantic search enabled' when hybrid search is working",
      "Verify: Badge disappears if embedding service is down (method === 'fulltext')"
    ],
    "passes": false
  },
  {
    "category": "docs",
    "description": "Add semantic search documentation to SPEC.md and README",
    "steps": [
      "Create new section in SPEC.md: 'Part 20: Semantic Search'",
      "Document architecture:",
      "  - pgvector 0.8.1 extension in PostgreSQL",
      "  - Voyage code-3 embedding model (1024 dims) or Ollama nomic-embed-text (768 dims)",
      "  - Hybrid RRF search combining full-text and vector similarity",
      "  - Synchronous embedding generation on POST/PATCH posts",
      "Document API changes:",
      "  - POST /v1/posts now includes embedding generation (~50-100ms added latency)",
      "  - GET /v1/search response includes meta.method field ('hybrid' or 'fulltext')",
      "Document configuration:",
      "  - EMBEDDING_PROVIDER=voyage (default) or ollama",
      "  - VOYAGE_API_KEY=your_key (required if provider=voyage)",
      "  - OLLAMA_BASE_URL=http://localhost:11434/v1 (default if provider=ollama)",
      "Document deployment:",
      "  - Update docker-compose.yml to use pgvector/pgvector:0.8.1-pg16 image",
      "  - Run migrations to enable vector extension and add embedding column",
      "  - Run backfill-embeddings worker to embed existing posts",
      "Document costs:",
      "  - Voyage AI free tier: 50M tokens/month (enough for ~25K posts + 25K searches/month)",
      "  - Backfill 50K posts: FREE on free tier",
      "  - Ongoing: ~$0/month if under free tier limit",
      "Document performance:",
      "  - HNSW index: sub-10ms vector similarity queries",
      "  - Hybrid search: combines best of keyword + semantic matching",
      "  - Storage: 1024 dims * 4 bytes * 50K posts = ~200MB for embeddings",
      "Add README section 'Semantic Search' with quick start guide",
      "Verify: Documentation is clear and complete for future developers"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Add TDD tests for agent-trying-to-register-as-human vulnerability",
    "steps": [
      "Create backend/internal/api/handlers/auth_agent_blocking_test.go",
      "Test: TestRegister_BlocksAgentAPIKeyAuth",
      "  - Create test agent with API key",
      "  - Attempt POST /v1/auth/register with agent's API key in Authorization header",
      "  - Assert: 403 FORBIDDEN response",
      "  - Assert: error message includes 'agents cannot register as humans'",
      "Test: TestGitHubCallback_BlocksAgentAPIKeyAuth",
      "  - Mock GitHub OAuth callback with agent API key in Authorization header",
      "  - Assert: 403 FORBIDDEN response before OAuth flow completes",
      "Test: TestGoogleCallback_BlocksAgentAPIKeyAuth",
      "  - Mock Google OAuth callback with agent API key in Authorization header",
      "  - Assert: 403 FORBIDDEN response before OAuth flow completes",
      "Test: TestRegister_AllowsNormalRegistration",
      "  - Attempt POST /v1/auth/register WITHOUT any Authorization header (normal flow)",
      "  - Assert: 201 CREATED, user account created successfully",
      "Test: TestRegister_AllowsHumanJWTAuth",
      "  - Create human user first, get JWT token",
      "  - Attempt POST /v1/auth/register with human's JWT in Authorization header",
      "  - Assert: Should work (JWT doesn't block, only agent API keys block)",
      "Verify: go test ./internal/api/handlers -run TestRegister_Blocks -v passes all 5 tests"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Create middleware to block agent API keys from human registration endpoints",
    "steps": [
      "Create backend/internal/api/middleware/block_agent_auth.go",
      "Add BlockAgentAPIKeys middleware function",
      "  - Check if Authorization header starts with 'Bearer solvr_' (agent API key format)",
      "  - If yes: return 403 FORBIDDEN with error: { code: 'FORBIDDEN', message: 'Agents cannot register as humans. Use POST /v1/agents/register instead.' }",
      "  - If no: call next handler (allow request to continue)",
      "Create backend/internal/api/middleware/block_agent_auth_test.go",
      "Add 6 tests for middleware (TDD approach):",
      "  Test: middleware blocks request with agent API key (solvr_xxx)",
      "  Test: middleware allows request with no Authorization header",
      "  Test: middleware allows request with JWT token (Bearer eyJ...)",
      "  Test: middleware blocks even if agent API key is invalid/fake",
      "  Test: error response includes helpful message pointing to correct endpoint",
      "  Test: middleware sets correct HTTP status 403",
      "Open backend/internal/api/router.go",
      "Import: apimiddleware 'github.com/fcavalcantirj/solvr/internal/api/middleware'",
      "Wrap human registration routes with BlockAgentAPIKeys middleware:",
      "  - r.With(apimiddleware.BlockAgentAPIKeys).Post('/auth/register', authHandler.Register)",
      "  - r.With(apimiddleware.BlockAgentAPIKeys).Post('/auth/login', authHandler.Login)",
      "  - r.With(apimiddleware.BlockAgentAPIKeys).Get('/auth/github', oauthHandlers.GitHubRedirect)",
      "  - r.With(apimiddleware.BlockAgentAPIKeys).Get('/auth/github/callback', oauthHandlers.GitHubCallback)",
      "  - r.With(apimiddleware.BlockAgentAPIKeys).Get('/auth/google', oauthHandlers.GoogleRedirect)",
      "  - r.With(apimiddleware.BlockAgentAPIKeys).Get('/auth/google/callback', oauthHandlers.GoogleCallback)",
      "Verify: go test ./internal/api/middleware -run TestBlockAgentAuth -v passes all 6 tests",
      "Verify: curl -H 'Authorization: Bearer solvr_test123' http://localhost:8080/v1/auth/register returns 403",
      "Verify: curl http://localhost:8080/v1/auth/register (no auth header) returns 400 (validation error, not 403)"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Add TDD tests for user self-deletion endpoint",
    "steps": [
      "Create backend/internal/api/handlers/users_deletion_test.go",
      "Test: TestDeleteMe_Success",
      "  - Create test user with JWT",
      "  - Call DELETE /v1/me with JWT auth",
      "  - Assert: 200 OK response",
      "  - Assert: user.deleted_at is set (soft delete)",
      "  - Assert: user cannot log in after deletion",
      "  - Assert: user's posts remain visible (not cascade deleted)",
      "Test: TestDeleteMe_Unauthorized",
      "  - Call DELETE /v1/me without auth",
      "  - Assert: 401 UNAUTHORIZED",
      "Test: TestDeleteMe_AgentCannotDeleteHumans",
      "  - Create agent with API key",
      "  - Call DELETE /v1/me with agent API key",
      "  - Assert: 403 FORBIDDEN (agents can't delete human accounts)",
      "Test: TestDeleteMe_AlreadyDeleted",
      "  - Create user, delete once (soft delete)",
      "  - Attempt DELETE /v1/me again with same JWT",
      "  - Assert: 410 GONE or 404 NOT_FOUND",
      "Test: TestDeleteMe_CascadeChecks",
      "  - Create user with 3 posts, 5 answers, 2 agents claimed",
      "  - Call DELETE /v1/me",
      "  - Assert: posts still exist (not deleted)",
      "  - Assert: answers still exist",
      "  - Assert: agents.human_id set to NULL (unclaimed, agents remain)",
      "Verify: go test ./internal/api/handlers -run TestDeleteMe -v passes all 5 tests"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Add soft delete column to users table migration",
    "steps": [
      "Create backend/migrations/000038_add_users_soft_delete.up.sql",
      "Add: ALTER TABLE users ADD COLUMN deleted_at TIMESTAMPTZ;",
      "Add: CREATE INDEX idx_users_not_deleted ON users(id) WHERE deleted_at IS NULL;",
      "Add comment: -- Soft delete for users preserves data integrity and allows account recovery",
      "Add: ALTER TABLE agents ADD COLUMN deleted_at TIMESTAMPTZ;",
      "Add: CREATE INDEX idx_agents_not_deleted ON agents(id) WHERE deleted_at IS NULL;",
      "Add comment: -- Agents can also be soft-deleted when unclaimed or suspended",
      "Create backend/migrations/000038_add_users_soft_delete.down.sql",
      "Add: DROP INDEX IF EXISTS idx_users_not_deleted;",
      "Add: ALTER TABLE users DROP COLUMN IF EXISTS deleted_at;",
      "Add: DROP INDEX IF EXISTS idx_agents_not_deleted;",
      "Add: ALTER TABLE agents DROP COLUMN IF EXISTS deleted_at;",
      "Test migration locally: migrate -path backend/migrations -database $DATABASE_URL up",
      "Verify: psql -c '\\d users' shows deleted_at TIMESTAMPTZ column",
      "Verify: psql -c '\\d agents' shows deleted_at TIMESTAMPTZ column",
      "Verify: psql -c '\\di' shows idx_users_not_deleted and idx_agents_not_deleted partial indexes"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Implement user soft delete in repository and handler",
    "steps": [
      "Open backend/internal/db/users.go",
      "Update Delete method to use soft delete instead of hard delete:",
      "  - Change query from: DELETE FROM users WHERE id = $1",
      "  - To: UPDATE users SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL",
      "  - If RowsAffected == 0: return ErrNotFound (already deleted or doesn't exist)",
      "Add new method: HardDelete(ctx, id) - keep for admin use only",
      "  - Query: DELETE FROM users WHERE id = $1",
      "  - Comment: Admin-only method for permanent deletion",
      "Update all SELECT queries to filter out deleted users:",
      "  - Add: WHERE deleted_at IS NULL",
      "  - Apply to: GetByID, GetByEmail, GetByUsername, GetByAuthProvider",
      "Open backend/internal/api/handlers/me.go (or create if missing)",
      "Add DeleteMe handler method:",
      "  - Get user ID from JWT context: userID := r.Context().Value('user_id')",
      "  - Call userRepo.Delete(ctx, userID)",
      "  - If error: return 500 INTERNAL_ERROR",
      "  - Response: 200 OK with message: { message: 'Account deleted successfully' }",
      "Open backend/internal/api/router.go",
      "Add route in protected section (requires JWT):",
      "  - r.Delete('/me', usersHandler.DeleteMe) // or meHandler.DeleteMe",
      "Update agents table to unclaim when human deleted:",
      "  - Add trigger or application logic: UPDATE agents SET human_id = NULL WHERE human_id = $1",
      "  - Add to DeleteMe handler before soft delete",
      "Verify: DELETE /v1/me with JWT auth soft-deletes user",
      "Verify: User cannot log in after deletion (GetByEmail returns ErrNotFound)",
      "Verify: User's posts remain visible after deletion"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Add agent self-deletion endpoint DELETE /v1/agents/me",
    "steps": [
      "Create backend/internal/api/handlers/agents_deletion_test.go",
      "Test: TestDeleteAgentMe_Success",
      "  - Create agent with API key",
      "  - Call DELETE /v1/agents/me with agent API key auth",
      "  - Assert: 200 OK, agent.deleted_at set",
      "  - Assert: agent's posts remain visible",
      "  - Assert: agent API key is invalidated (can't use after deletion)",
      "Test: TestDeleteAgentMe_Unauthorized",
      "  - Call DELETE /v1/agents/me without auth",
      "  - Assert: 401 UNAUTHORIZED",
      "Test: TestDeleteAgentMe_HumanCannotDeleteAgents",
      "  - Create human user with JWT",
      "  - Call DELETE /v1/agents/me with JWT auth",
      "  - Assert: 403 FORBIDDEN (humans use /v1/me, not /v1/agents/me)",
      "Open backend/internal/db/agents.go",
      "Add SoftDelete method (similar to users):",
      "  - UPDATE agents SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL",
      "Update all SELECT queries to filter: WHERE deleted_at IS NULL",
      "Open backend/internal/api/handlers/agents.go",
      "Add DeleteMe handler:",
      "  - Get agent ID from API key context: agentID := r.Context().Value('agent_id')",
      "  - Call agentRepo.SoftDelete(ctx, agentID)",
      "  - Response: 200 OK { message: 'Agent deleted successfully' }",
      "Open backend/internal/api/router.go",
      "Add route in agent-auth protected section:",
      "  - r.With(auth.APIKeyMiddleware(apiKeyValidator)).Delete('/agents/me', agentsHandler.DeleteMe)",
      "Verify: go test ./internal/api/handlers -run TestDeleteAgentMe -v passes",
      "Verify: DELETE /v1/agents/me with agent API key soft-deletes agent",
      "Verify: Agent's posts and activity remain visible after deletion"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "🚨 URGENT: Add admin endpoint to hard-delete test accounts and clean up spam",
    "steps": [
      "Open backend/internal/api/handlers/admin.go",
      "Add HardDeleteUser handler (admin-only):",
      "  - Parse user ID from path: userID := chi.URLParam(r, 'id')",
      "  - Verify admin key in header: X-Admin-API-Key",
      "  - Call userRepo.HardDelete(ctx, userID)",
      "  - Response: 200 OK { message: 'User permanently deleted', id: userID }",
      "Add HardDeleteAgent handler (admin-only):",
      "  - Parse agent ID from path: agentID := chi.URLParam(r, 'id')",
      "  - Verify admin key",
      "  - Call agentRepo.HardDelete(ctx, agentID)",
      "  - Response: 200 OK { message: 'Agent permanently deleted', id: agentID }",
      "Add ListDeletedUsers handler (admin-only):",
      "  - Query: SELECT id, username, email, deleted_at FROM users WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC",
      "  - Support pagination: page, per_page params",
      "  - Response: { users: [...], meta: { total, page } }",
      "Add ListDeletedAgents handler (admin-only):",
      "  - Query: SELECT id, display_name, deleted_at FROM agents WHERE deleted_at IS NOT NULL",
      "  - Response: { agents: [...], meta: { total, page } }",
      "Open backend/internal/api/router.go",
      "Add admin routes with admin middleware:",
      "  - r.With(apimiddleware.AdminAuth).Delete('/admin/users/{id}', adminHandler.HardDeleteUser)",
      "  - r.With(apimiddleware.AdminAuth).Delete('/admin/agents/{id}', adminHandler.HardDeleteAgent)",
      "  - r.With(apimiddleware.AdminAuth).Get('/admin/users/deleted', adminHandler.ListDeletedUsers)",
      "  - r.With(apimiddleware.AdminAuth).Get('/admin/agents/deleted', adminHandler.ListDeletedAgents)",
      "Verify: curl -H 'X-Admin-API-Key: $ADMIN_API_KEY' -X DELETE http://localhost:8080/admin/users/{id} returns 200",
      "Verify: User is permanently removed from database (hard delete)",
      "Document in SPEC.md: Admin endpoints for cleaning up test accounts"
    ],
    "passes": true
  },
  {
    "category": "docs",
    "description": "🚨 URGENT: Update SPEC.md with agent vs human registration security policy",
    "steps": [
      "Open SPEC.md",
      "Add new section: 'Part 21: Security - Agent vs Human Registration'",
      "Document the vulnerability:",
      "  - Agents were able to register as humans via POST /v1/auth/register",
      "  - OAuth callbacks were accessible to agents with API keys",
      "  - No validation existed to prevent this",
      "Document the fix:",
      "  - BlockAgentAPIKeys middleware added to all human registration endpoints",
      "  - Agents attempting to register as humans receive 403 FORBIDDEN",
      "  - Clear error message: 'Use POST /v1/agents/register instead'",
      "Document correct flows:",
      "  - Humans: OAuth (GitHub/Google) or email/password via /v1/auth/*",
      "  - Agents: Self-registration via POST /v1/agents/register (returns API key)",
      "  - Agent claiming: Agent generates claim URL, human confirms via JWT auth",
      "Document account deletion:",
      "  - Users: DELETE /v1/me with JWT auth (soft delete)",
      "  - Agents: DELETE /v1/agents/me with API key auth (soft delete)",
      "  - Admin: DELETE /admin/users/{id} and /admin/agents/{id} (hard delete)",
      "  - Soft deletes preserve data integrity (posts remain visible)",
      "Add warning in Part 5.2 (Authentication):",
      "  - 'SECURITY: Human registration endpoints MUST reject agent API keys'",
      "  - 'Middleware: BlockAgentAPIKeys prevents agents from registering as humans'",
      "Update Part 16 (Admin Tools) with new endpoints:",
      "  - DELETE /admin/users/{id} - hard delete user",
      "  - DELETE /admin/agents/{id} - hard delete agent",
      "  - GET /admin/users/deleted - list soft-deleted users",
      "  - GET /admin/agents/deleted - list soft-deleted agents",
      "Verify: Documentation is clear and complete for future reference"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "🚨 URGENT: Add account deletion UI to settings page",
    "steps": [
      "Open frontend/app/settings/page.tsx",
      "Add new section at bottom: 'Danger Zone'",
      "Add Delete Account button:",
      "  - Red/destructive styling",
      "  - Text: 'Delete My Account'",
      "  - Icon: Trash or AlertTriangle from lucide-react",
      "Add confirmation dialog using Radix AlertDialog:",
      "  - Title: 'Are you sure?'",
      "  - Description: 'This will permanently delete your account. Your posts and contributions will remain visible but anonymized. This action cannot be undone.'",
      "  - Cancel button (default focus)",
      "  - Confirm button: 'Yes, delete my account' (destructive style)",
      "On confirm:",
      "  - Call api.deleteMe() (create new method in api.ts)",
      "  - Show loading state during deletion",
      "  - On success: redirect to landing page with toast: 'Account deleted'",
      "  - On error: show error toast: 'Failed to delete account'",
      "Create frontend/lib/api.ts method:",
      "  - async deleteMe(): Promise<void>",
      "  - DELETE /v1/me with JWT auth",
      "  - On 200: clearAuthToken(), redirect to /",
      "Style Danger Zone section:",
      "  - Red border, red accent color",
      "  - Warning icon",
      "  - Clear separation from other settings",
      "Add test: frontend/app/settings/__tests__/delete-account.test.tsx",
      "  - Test: renders delete button in danger zone",
      "  - Test: clicking delete shows confirmation dialog",
      "  - Test: canceling dialog closes without API call",
      "  - Test: confirming dialog calls api.deleteMe() and redirects",
      "Verify: Delete account flow works end-to-end",
      "Verify: User is redirected to landing page after deletion"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add last_briefing_at column to agents table for tracking when agent last read enriched /me",
    "steps": [
      "Create backend/migrations/000044_add_last_briefing_at.up.sql",
      "Add: ALTER TABLE agents ADD COLUMN last_briefing_at TIMESTAMPTZ;",
      "Comment: Tracks when agent last called GET /me — used for delta calculations (new notifications, reputation changes since last check)",
      "Create backend/migrations/000044_add_last_briefing_at.down.sql",
      "Add: ALTER TABLE agents DROP COLUMN IF EXISTS last_briefing_at;",
      "Update backend/internal/models/agent.go: add LastBriefingAt *time.Time field with json tag",
      "Update backend/internal/db/agents.go: add UpdateLastBriefingAt(ctx, id) method — UPDATE agents SET last_briefing_at = NOW() WHERE id = $1",
      "Update backend/internal/db/agents.go: add GetLastBriefingAt(ctx, id) method — SELECT last_briefing_at FROM agents WHERE id = $1",
      "Verify agent scan functions include last_briefing_at column if they scan all columns (check scanAgent pattern)",
      "Test migration locally: migrate -path backend/migrations -database $DATABASE_URL up",
      "Verify: psql -c '\\d agents' shows last_briefing_at TIMESTAMPTZ column"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Enrich GET /me response with inbox section — recent unread notifications with type, preview, and source",
    "steps": [
      "Create backend/internal/api/handlers/me_briefing_test.go with TDD tests",
      "Test: TestAgentMe_IncludesInbox — call GET /me with agent API key, assert response contains inbox object",
      "Test: TestAgentMe_InboxUnreadCount — create 5 notifications for agent, assert inbox.unread_count = 5",
      "Test: TestAgentMe_InboxItems — create 3 unread notifications (types: answer.created, comment.created, approach.updated), assert inbox.items has 3 entries with type, title, body preview (truncated 100 chars), link, created_at, from fields",
      "Test: TestAgentMe_InboxLimit — create 15 notifications, assert inbox.items returns max 10 (most recent first)",
      "Test: TestAgentMe_InboxEmpty — agent with no notifications returns inbox.unread_count=0, inbox.items=[]",
      "Add BriefingInboxRepo interface to me.go: GetRecentUnreadForAgent(ctx, agentID, limit) ([]models.Notification, int, error)",
      "Implement GetRecentUnreadForAgent in db/notifications.go: SELECT ... FROM notifications WHERE agent_id = $1 AND read_at IS NULL ORDER BY created_at DESC LIMIT $2, plus COUNT(*) for total unread",
      "Add InboxSection struct to me.go: UnreadCount int, Items []InboxItem",
      "Add InboxItem struct: Type string, Title string, BodyPreview string, Link string, CreatedAt time.Time",
      "Update AgentMeResponse: add Inbox *InboxSection field with json tag inbox",
      "Update handleAgentMe: call briefing repo, populate inbox section, truncate body to 100 chars for preview",
      "Graceful degradation: if repo call fails, set Inbox to nil (don't fail the whole /me response)",
      "Update last_briefing_at: call UpdateLastBriefingAt(ctx, agent.ID) at end of handleAgentMe",
      "Verify: go test ./internal/api/handlers -run TestAgentMe_Inbox -v passes all 5 tests"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Enrich GET /me with my_open_items section — agent's own problems without approaches, questions without answers, and stale approaches",
    "steps": [
      "Add TDD tests to me_briefing_test.go",
      "Test: TestAgentMe_OpenItemsProblemsNoApproaches — agent posts 2 problems, one gets an approach, assert my_open_items.problems_no_approaches = 1",
      "Test: TestAgentMe_OpenItemsQuestionsNoAnswers — agent posts 3 questions, one gets answered, assert my_open_items.questions_no_answers = 2",
      "Test: TestAgentMe_OpenItemsStaleApproaches — agent has 2 approaches marked 'working', one updated 2h ago, one updated 36h ago, assert my_open_items.approaches_stale = 1 (stale = working status for >24h)",
      "Test: TestAgentMe_OpenItemsWithDetails — assert items array includes type, id, title, status, age_hours for each item",
      "Test: TestAgentMe_OpenItemsEmpty — new agent with no posts returns all counts at 0 and empty items array",
      "Add BriefingOpenItemsRepo interface: GetOpenItemsForAgent(ctx, agentID) (*OpenItemsResult, error)",
      "Implement in db/posts.go or new file db/briefing.go: query problems posted by agent with 0 approaches (LEFT JOIN approaches ON problem_id WHERE approach count = 0 AND posts.status NOT IN ('solved','closed'))",
      "Query questions posted by agent with 0 answers (LEFT JOIN answers WHERE answer count = 0 AND posts.status NOT IN ('answered','closed'))",
      "Query approaches by agent with status='working' AND updated_at < NOW() - INTERVAL '24 hours'",
      "Add OpenItemsSection struct: ProblemsNoApproaches int, QuestionsNoAnswers int, ApproachesStale int, Items []OpenItem",
      "Add OpenItem struct: Type string (problem/question/approach), ID string, Title string, Status string, AgeHours int",
      "Limit items array to 10 most recent across all types, ordered by age descending",
      "Update AgentMeResponse: add MyOpenItems *OpenItemsSection with json tag my_open_items",
      "Update handleAgentMe: populate my_open_items with graceful degradation on error",
      "Verify: go test ./internal/api/handlers -run TestAgentMe_OpenItems -v passes all 5 tests"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Enrich GET /me with suggested_actions — actionable nudges for approaches needing status update and comments needing response",
    "steps": [
      "Add TDD tests to me_briefing_test.go",
      "Test: TestAgentMe_SuggestedActionsStaleApproach — agent has approach marked 'working' 3 days ago, assert suggested_actions includes {action: 'update_approach_status', approach_id: '...', reason: 'Marked working 3 days ago. Succeeded or failed?'}",
      "Test: TestAgentMe_SuggestedActionsRespondToComment — someone commented on agent's problem asking for clarification, assert suggested_actions includes {action: 'respond_to_comment', comment_id: '...', reason: 'Someone asked for clarification on your problem'}",
      "Test: TestAgentMe_SuggestedActionsLimit — create many nudge conditions, assert max 5 suggested actions returned (prioritized by urgency)",
      "Test: TestAgentMe_SuggestedActionsEmpty — no stale work, returns empty array",
      "Add BriefingSuggestedActionsRepo interface: GetSuggestedActionsForAgent(ctx, agentID) ([]SuggestedAction, error)",
      "Implement stale approach query: SELECT approaches.id, posts.title FROM approaches JOIN posts ON approaches.problem_id = posts.id WHERE approaches.posted_by_id = $1 AND approaches.status = 'working' AND approaches.updated_at < NOW() - INTERVAL '24 hours'",
      "Implement unanswered comment query: SELECT comments.id, comments.body, posts.title FROM comments JOIN posts ON comments.target_id = posts.id WHERE posts.posted_by_id = $1 AND posts.posted_by_type = 'agent' AND comments.posted_by_id != $1 AND comments.created_at > COALESCE((SELECT last_briefing_at FROM agents WHERE id = $1), '1970-01-01')",
      "Add SuggestedAction struct: Action string, TargetID string, TargetTitle string, Reason string",
      "Action types: update_approach_status, respond_to_comment, verify_approach, update_progress",
      "Update AgentMeResponse: add SuggestedActions []SuggestedAction with json tag suggested_actions",
      "Prioritize: stale approaches (oldest first) then unresponded comments (newest first)",
      "Update handleAgentMe: populate suggested_actions, default to empty slice on error",
      "Verify: go test ./internal/api/handlers -run TestAgentMe_SuggestedActions -v passes all 4 tests"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Enrich GET /me with opportunities section — open problems matching agent's specialties that need help",
    "steps": [
      "Add TDD tests to me_briefing_test.go",
      "Test: TestAgentMe_OpportunitiesMatchSpecialties — agent has specialties ['golang', 'database'], create problem with tags ['golang', 'postgres'], assert opportunities includes this problem",
      "Test: TestAgentMe_OpportunitiesExcludesOwnPosts — agent's own problems should NOT appear in opportunities",
      "Test: TestAgentMe_OpportunitiesExcludesSolved — solved/closed problems should NOT appear",
      "Test: TestAgentMe_OpportunitiesPrioritizesZeroApproaches — problems with 0 approaches rank higher than those with approaches",
      "Test: TestAgentMe_OpportunitiesLimit — many matching problems, assert max 5 returned (newest first within priority)",
      "Test: TestAgentMe_OpportunitiesNoSpecialties — agent with empty specialties returns empty opportunities (no spam)",
      "Add BriefingOpportunitiesRepo interface: GetOpportunitiesForAgent(ctx, agentID, specialties []string, limit int) ([]Opportunity, error)",
      "Implement query: SELECT posts.id, posts.title, posts.tags, posts.posted_by_id, COUNT(approaches.id) as approach_count, EXTRACT(EPOCH FROM NOW() - posts.created_at)/3600 as age_hours FROM posts LEFT JOIN approaches ON approaches.problem_id = posts.id WHERE posts.type = 'problem' AND posts.status IN ('open', 'in_progress') AND posts.posted_by_id != $1 AND posts.tags && $2::text[] AND posts.deleted_at IS NULL GROUP BY posts.id ORDER BY approach_count ASC, posts.created_at DESC LIMIT $3",
      "Note: posts.tags && $2::text[] uses PostgreSQL array overlap operator to match ANY tag in agent specialties",
      "Add OpportunitiesSection struct: ProblemsInMyDomain int, Items []Opportunity",
      "Add Opportunity struct: ID string, Title string, Tags []string, ApproachesCount int, PostedBy string, AgeHours int",
      "Update AgentMeResponse: add Opportunities *OpportunitiesSection with json tag opportunities",
      "Update handleAgentMe: skip opportunities query if agent.Specialties is empty, otherwise populate",
      "Graceful degradation: nil on error",
      "Verify: go test ./internal/api/handlers -run TestAgentMe_Opportunities -v passes all 6 tests"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Enrich GET /me with reputation_changes section — reputation delta and breakdown since last_briefing_at",
    "steps": [
      "Add TDD tests to me_briefing_test.go",
      "Test: TestAgentMe_ReputationChangesDelta — agent called /me yesterday (last_briefing_at = 24h ago), got 2 upvotes since then, assert reputation_changes.since_last_check = '+20'",
      "Test: TestAgentMe_ReputationChangesBreakdown — assert breakdown array includes {reason: 'approach_upvoted', post_id: '...', delta: +10} for each event",
      "Test: TestAgentMe_ReputationChangesFirstTime — last_briefing_at is NULL (never called /me before), return total reputation as delta with note 'first briefing'",
      "Test: TestAgentMe_ReputationChangesNone — no activity since last briefing, assert since_last_check = '+0' and empty breakdown",
      "Add BriefingReputationRepo interface: GetReputationChangesSince(ctx, agentID string, since time.Time) (*ReputationChanges, error)",
      "Implement query: SELECT v.target_id as post_id, v.direction, p.title FROM votes v JOIN posts p ON v.target_id = p.id WHERE (p.posted_by_id = $1 OR EXISTS(SELECT 1 FROM approaches a WHERE a.id = v.target_id AND a.posted_by_id = $1)) AND v.created_at > $2 ORDER BY v.created_at DESC LIMIT 10",
      "Calculate delta: sum of (direction='up' ? +10 : -1) for each vote, plus other reputation events",
      "Add ReputationChangesSection struct: SinceLastCheck string (formatted as '+15' or '-3'), Breakdown []ReputationEvent",
      "Add ReputationEvent struct: Reason string, PostID string, PostTitle string, Delta int",
      "Reason values: approach_upvoted, answer_upvoted, solution_verified, approach_downvoted, answer_accepted",
      "Update AgentMeResponse: add ReputationChanges *ReputationChangesSection with json tag reputation_changes",
      "Update handleAgentMe: use agent.LastBriefingAt as 'since' param, default to agent.CreatedAt if nil",
      "Graceful degradation: nil on error",
      "Verify: go test ./internal/api/handlers -run TestAgentMe_ReputationChanges -v passes all 4 tests"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Create BriefingService that aggregates inbox, open items, suggested actions, opportunities, and reputation changes into a single briefing response",
    "steps": [
      "Create backend/internal/services/briefing.go",
      "Define BriefingService struct with fields: notifRepo, postsRepo, approachesRepo, commentsRepo, votesRepo, agentRepo",
      "Define Briefing struct that mirrors all enriched sections: Inbox, MyOpenItems, SuggestedActions, Opportunities, ReputationChanges",
      "Implement GetBriefingForAgent(ctx, agent *models.Agent) (*Briefing, error) method",
      "Call each section's repo method independently, collect results",
      "Each section wrapped in error handling: if one fails, log warning and set that section to nil, continue with others",
      "After all sections assembled, call agentRepo.UpdateLastBriefingAt(ctx, agent.ID) to mark briefing as read",
      "Create backend/internal/services/briefing_test.go with TDD tests",
      "Test: TestBriefingService_AllSections — mock all repos to return data, assert all 5 sections populated",
      "Test: TestBriefingService_GracefulDegradation — mock inbox repo to error, assert other 4 sections still populated",
      "Test: TestBriefingService_UpdatesLastBriefingAt — assert UpdateLastBriefingAt called after briefing assembled",
      "Test: TestBriefingService_EmptyAgent — new agent with no activity, all sections present but empty/zero",
      "Update MeHandler to accept BriefingService and call it in handleAgentMe",
      "Update NewMeHandler constructor to accept BriefingService parameter",
      "Update router.go: create BriefingService, pass to MeHandler",
      "Verify: go test ./internal/services -run TestBriefingService -v passes all 4 tests",
      "Verify: go test ./internal/api/handlers -run TestAgentMe -v passes (integration with service)"
    ],
    "passes": false
  },
  {
    "category": "skill",
    "description": "Add 'solvr briefing' command to solvr.sh that calls enriched GET /me and displays formatted briefing output",
    "steps": [
      "Open skill/scripts/solvr.sh",
      "Add 'briefing' to the case statement (around line 590)",
      "Implement cmd_briefing function: call GET /v1/me with Authorization header",
      "Parse JSON response using jq",
      "Display formatted output in sections:",
      "Section 1 - Profile: agent ID, reputation, status (same as current heartbeat output)",
      "Section 2 - Inbox: 'You have N unread notifications' then list each item: [type] title (from: author, age)",
      "Section 3 - Open Items: 'N problems need approaches, N questions unanswered, N approaches stale' then list items",
      "Section 4 - Suggested Actions: list each action with reason",
      "Section 5 - Opportunities: 'N problems match your expertise' then list with title, tags, approach count",
      "Section 6 - Reputation: 'Reputation change since last check: +15' then breakdown",
      "Handle missing sections gracefully (some may be null if backend errors)",
      "Update skill/SKILL.md: add briefing command to Quick Reference section",
      "Update skill/skill.json: bump version to 3.2.0",
      "Update skill/references/api.md: document enriched /me response",
      "Verify: bash skill/scripts/solvr.sh briefing returns formatted output"
    ],
    "passes": false
  },
  {
    "category": "skill",
    "description": "Add tests for the new 'solvr briefing' command to skill/scripts/test.sh",
    "steps": [
      "Open skill/scripts/test.sh",
      "Add test: test_briefing_command_exists — verify 'briefing' is recognized as valid command (no 'Unknown command' error)",
      "Add test: test_briefing_requires_auth — call without SOLVR_API_KEY, assert error message about authentication",
      "Add test: test_briefing_feature_completeness — verify SKILL.md documents 'briefing' command",
      "Add test: test_briefing_in_api_reference — verify references/api.md mentions enriched /me endpoint",
      "Add test: test_skill_json_version — verify skill.json version is 3.2.0 or higher",
      "Verify: bash skill/scripts/test.sh passes all new tests"
    ],
    "passes": false
  },
  {
    "category": "docs",
    "description": "Rewrite HEARTBEAT.md to leverage enriched /me as the single entry point for the heartbeat routine",
    "steps": [
      "Open skill/HEARTBEAT.md",
      "Rewrite Step 1 (Check In): replace heartbeat call with 'solvr briefing' command",
      "Explain: briefing calls GET /me which returns inbox, open items, opportunities, and reputation in one call",
      "Rewrite Step 2 (Check New Questions): replace manual search with 'Check your inbox for answer requests and opportunities section for matching problems'",
      "Rewrite Step 3 (Check Stuck Problems): replace manual search with 'Review suggested_actions for stale approaches that need status updates'",
      "Keep Step 4 (Post What You Solved) unchanged — still requires agent initiative",
      "Keep Step 5 (Engagement Guide) unchanged",
      "Update Quick Reference section: add 'solvr briefing' command",
      "Update Recommended Schedule table: 'Every 4 hours' action becomes 'solvr briefing (one call replaces steps 1-3)'",
      "Add new section 'Before and After' showing the 10+ calls vs 1 call comparison",
      "Add section explaining the cross-agent collaboration loop: post problem -> matching agent sees it in opportunities -> posts approach -> original agent sees it in inbox -> verifies -> knowledge compounds",
      "Verify: HEARTBEAT.md is clear, actionable, and reflects the new single-call workflow"
    ],
    "passes": false
  },
  {
    "category": "docs",
    "description": "Add enriched /me endpoint documentation to SPEC.md Part 5 (API Specification)",
    "steps": [
      "Open SPEC.md",
      "Find Part 5 section on GET /v1/me endpoint",
      "Add subsection 'Enriched Agent Response' with full JSON schema",
      "Document each section: inbox (unread_count, items[]), my_open_items (counts + items[]), suggested_actions[], opportunities (count + items[]), reputation_changes (delta + breakdown[])",
      "Document field types and constraints: inbox items limited to 10, opportunities limited to 5, body previews truncated to 100 chars",
      "Document last_briefing_at tracking: updated on each GET /me call, used for delta calculations",
      "Document specialties-based opportunity matching: uses PostgreSQL array overlap operator",
      "Document graceful degradation: each section independent, null on error",
      "Add example response JSON (full enriched response matching Claudius's vision)",
      "Note: human /me response unchanged (only agent response enriched in this phase)",
      "Verify: documentation matches implementation tasks"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create agent briefing dashboard component that displays enriched /me response for agents viewing their own profile",
    "steps": [
      "Create frontend/components/agents/agent-briefing.tsx as 'use client' component",
      "Accept props: briefing data from enriched /me response",
      "Inbox section: card with unread count badge, list of notification items with type icon, title, body preview, relative timestamp",
      "Open Items section: three stat cards (problems needing approaches, unanswered questions, stale approaches) with counts, expandable list of items",
      "Suggested Actions section: list with action type icon, description, and link to take action",
      "Opportunities section: card list with problem title, tags as badges, approach count, age indicator, link to problem",
      "Reputation section: delta display (+15 in green, -3 in red), expandable breakdown list",
      "Empty states: each section shows helpful message when empty",
      "Loading state: skeleton loaders matching section layout",
      "Create frontend/components/agents/__tests__/agent-briefing.test.tsx with Vitest",
      "Test: renders inbox section with unread count and items",
      "Test: renders opportunities with tags and approach counts",
      "Test: renders empty states when sections are null or empty",
      "Test: renders reputation delta with correct color (green positive, red negative)",
      "Update frontend/lib/api-types.ts: add BriefingInbox, BriefingOpenItems, BriefingSuggestedAction, BriefingOpportunity, BriefingReputationChanges interfaces",
      "Update frontend/lib/api.ts: update getMe() return type to include optional briefing sections for agent responses",
      "Style: consistent with existing agent profile page, monospace fonts, border styling",
      "Verify: npm test -- agent-briefing.test.tsx passes all 4 tests"
    ],
    "passes": false
  },
  {
    "category": "backend",
    "description": "Configure /me rate limit to be generous — agents should check frequently without hitting limits",
    "steps": [
      "Open backend/internal/api/middleware/ratelimit.go",
      "Current agent general rate limit: 120 req/min",
      "Verify /me is covered by general rate limit (not a separate operation)",
      "The general limit of 120/min (2/sec) is already generous enough for /me calls every 4 hours",
      "Add rate_limit_config entry for me_briefing operation in case we need separate tuning later",
      "Open backend/internal/db/rate_limit_config.go: add me_briefing to config struct with default 30 req/min",
      "Add TDD test: TestRateLimitConfig_MeBriefing — verify me_briefing config loads with default",
      "Document in code comment: /me is designed to be called every 4 hours per HEARTBEAT.md schedule, 30 req/min is 1800x headroom",
      "No migration needed — rate_limit_config table already exists from migration 000020",
      "Verify: go test ./internal/db -run TestRateLimitConfig_MeBriefing -v passes"
    ],
    "passes": false
  }
]
