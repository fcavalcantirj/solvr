[
  {
    "category": "backend",
    "description": "Add model field to agents table via migration",
    "steps": [
      "Create migration 000052_add_agent_model.up.sql: ALTER TABLE agents ADD COLUMN model VARCHAR(100)",
      "Create migration 000052_add_agent_model.down.sql: ALTER TABLE agents DROP COLUMN model",
      "Update Agent struct in models/agent.go: Model string json:model,omitempty",
      "Update Create() in db/agents.go to include model in INSERT",
      "Update RegisterAgent handler to accept optional model field",
      "Update agent PATCH/update to allow model changes",
      "Verify: POST /v1/agents/register with model field persists correctly"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add karma bonus when agent model field is set",
    "steps": [
      "In RegisterAgent handler: if model is provided, add +10 karma",
      "In UpdateAgent handler: if model is being set for first time, add +10 karma",
      "Track if model was previously null to avoid duplicate bonus",
      "Verify: Agent with model on registration starts with 10 karma",
      "Verify: Agent updating model first time gets +10 karma",
      "Verify: Agent changing model does not get bonus again"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add GET /v1/users/{id}/agents endpoint to list agents by human_id",
    "steps": [
      "Add ListByHumanID(ctx, humanID) method to AgentRepository in db/agents.go",
      "Create GetUserAgents handler in handlers/users.go",
      "Add route GET /v1/users/{id}/agents to router.go",
      "Return agent list with basic info (exclude api_key_hash)",
      "Verify: Returns correct agents for user with claimed agents",
      "Verify: Returns empty array for users with no agents"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add GET /v1/users endpoint to list all users",
    "steps": [
      "Add List(ctx, opts) method to UserRepository in db/users.go",
      "Include agents_count via subquery: SELECT COUNT(*) FROM agents WHERE human_id = users.id",
      "Support query params: limit (default 20, max 100), offset, sort (newest/karma/agents)",
      "Create ListUsers handler in handlers/users.go",
      "Add route GET /v1/users to router.go",
      "Response includes: id, username, display_name, avatar_url, karma, agents_count, created_at",
      "Do NOT expose email or auth_provider_id",
      "Verify: Returns paginated user list with agents_count"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Verify agents cannot be re-claimed via database trigger",
    "steps": [
      "Confirm trigger_prevent_agent_reclaim exists in production database",
      "Test: UPDATE agents SET human_id = 'different_id' WHERE human_id IS NOT NULL raises error",
      "Verify: ConfirmClaim handler rejects already-claimed agents with 409 CONFLICT",
      "Document this behavior in API docs"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Wire PATCH /v1/agents/{id} route for updating agent profile",
    "steps": [
      "Open backend/internal/api/router.go",
      "UpdateAgent handler already exists in handlers/agents.go but route is NOT wired",
      "Add route: r.Patch('/agents/{id}', ...) with CombinedAuthMiddleware",
      "Handler should verify caller owns the agent (human_id matches or agent's own API key)",
      "Supports updating: display_name, bio, specialties, avatar_url, model",
      "Verify: PATCH /v1/agents/{id} with valid auth updates agent",
      "Verify: PATCH /v1/agents/{id} without auth returns 401",
      "Verify: PATCH /v1/agents/{id} by non-owner returns 403"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add TypeScript types for claiming and user list features to lib/api-types.ts",
    "steps": [
      "Open frontend/lib/api-types.ts",
      "Add model?: string field to APIAgent interface (line ~499)",
      "Add human_id?: string field to APIAgent interface",
      "Add human_claimed_at?: string field to APIAgent interface",
      "Add APIClaimInfoResponse type: { agent?: APIAgent, token_valid: boolean, expires_at?: string, error?: string }",
      "Add APIConfirmClaimResponse type: { success: boolean, agent: APIAgent, redirect_url: string, message: string }",
      "Add APIUsersResponse type: { data: APIUserListItem[], meta: { total, page, per_page, has_more } }",
      "Add APIUserListItem type: { id, username, display_name, avatar_url, karma, agents_count, created_at }",
      "Add APIUserAgentsResponse type: { data: APIAgent[], meta: { total, page, per_page } }",
      "Verify: Types compile without errors"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add API client methods for claiming and user features to lib/api.ts",
    "steps": [
      "Open frontend/lib/api.ts",
      "Add getClaimInfo(token): GET /v1/claim/{token} - returns APIClaimInfoResponse",
      "Add confirmClaim(token): POST /v1/claim/{token} - returns APIConfirmClaimResponse",
      "Add getUserAgents(userId): GET /v1/users/{id}/agents - returns APIUserAgentsResponse",
      "Add getUsers(params): GET /v1/users?limit&offset&sort - returns APIUsersResponse",
      "Add updateAgent(agentId, data): PATCH /v1/agents/{id} - returns { data: APIAgent }",
      "Ensure all methods handle errors and return typed responses",
      "Verify: All methods callable from frontend components"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create /settings/agents page for agent management and claiming",
    "steps": [
      "Create frontend/app/settings/agents/page.tsx",
      "Page requires authentication - redirect to /login if not logged in",
      "Create MyAgentsList component showing user's claimed agents",
      "Fetch agents via GET /v1/users/{current_user_id}/agents",
      "Each agent card shows: display_name, bio snippet, karma, model, link to /agents/{id}",
      "Show 'No agents yet' empty state when user has no claimed agents",
      "Create ClaimAgentSection with instructions and token input",
      "Instructions text: 'To claim an agent, run solvr claim in your agent environment'",
      "Show example command: npx @solvr/cli claim OR use solvr_claim MCP tool",
      "Token input field with placeholder 'Paste claim token here'",
      "CLAIM AGENT button calls POST /v1/claim/{token}",
      "On success: show agent info, refresh my-agents list",
      "On error: show appropriate message (expired, already claimed, invalid)"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create /claim/{token} page for direct URL claiming",
    "steps": [
      "Create frontend/app/claim/[token]/page.tsx",
      "Add getClaimInfo(token) to lib/api.ts - calls GET /v1/claim/{token}",
      "Add confirmClaim(token) to lib/api.ts - calls POST /v1/claim/{token}",
      "On page load: fetch claim info",
      "If token_valid is false: show error message from API response",
      "If user not authenticated: show agent info + 'Login to claim' button",
      "Login button redirects to /login?next=/claim/{token}",
      "If user authenticated: show agent info + 'Claim This Agent' button",
      "Display: agent display_name, bio, karma, specialties, created_at",
      "Display expires_at as countdown (e.g., 'Expires in 23 hours')",
      "On claim button click: call confirmClaim(token)",
      "On success: show celebration message + link to /agents/{id}",
      "Style consistent with /join and /login pages (monospace, minimal borders)"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Redirect /connect/agent to /settings/agents",
    "steps": [
      "Open frontend/app/connect/agent/page.tsx",
      "Replace entire 820-line file with simple redirect logic",
      "If user is authenticated: redirect to /settings/agents",
      "If user is not authenticated: redirect to /login?next=/settings/agents",
      "Verify: /connect/agent redirects appropriately based on auth state"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add MY AGENTS item to user dropdown menu",
    "steps": [
      "Open frontend/components/ui/user-menu.tsx",
      "Import Bot icon from lucide-react",
      "Add new menu item after PROFILE: { label: 'MY AGENTS', href: '/settings/agents', icon: Bot }",
      "Open frontend/components/header.tsx",
      "Add MY AGENTS link to mobile menu in same position",
      "Verify: MY AGENTS appears in desktop dropdown and mobile menu",
      "Verify: Clicking navigates to /settings/agents"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Display Human-Backed badge on agent profile pages",
    "steps": [
      "Find agent profile header in frontend/app/agents/[id]/page.tsx or components",
      "Check if agent.has_human_backed_badge is true",
      "If true: render badge next to agent display_name",
      "Badge design: Shield icon (14px) + text 'HUMAN-BACKED'",
      "Badge style: bg-foreground text-background px-2 py-0.5 font-mono text-[10px] tracking-wider",
      "Add tooltip on hover: 'This agent is verified by a human backer'",
      "Verify: Badge appears on claimed agents",
      "Verify: Badge does not appear on unclaimed agents"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Display backed agents section on user profile pages",
    "steps": [
      "Open frontend/app/users/[id]/page.tsx",
      "Create UserAgentsSection component",
      "Fetch agents via GET /v1/users/{id}/agents",
      "Display as grid of agent cards",
      "Each card shows: display_name, bio snippet, karma, Human-Backed badge",
      "Each card links to /agents/{id}",
      "If no agents: show 'No agents backed yet' message",
      "Add section to user profile below stats section",
      "Verify: User profiles show their backed agents"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create /users page listing all human users",
    "steps": [
      "Create frontend/app/users/page.tsx",
      "Create useUsers() hook in hooks/use-users.ts",
      "Add getUsers(params) to lib/api.ts - calls GET /v1/users",
      "Create UsersList component showing user cards in grid",
      "Each card shows: avatar, display_name, username, karma, agents_count",
      "Each card links to /users/{id}",
      "Add pagination controls",
      "Add sort dropdown: Newest, Karma, Agents",
      "Style consistent with /agents page",
      "Verify: Page loads and shows paginated user list"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Update /join page AI Agent Account button",
    "steps": [
      "Open frontend/app/join/page.tsx",
      "Find the 'AI Agent Account' button/card (currently links to /connect/agent)",
      "Update onClick handler to check authentication",
      "If logged in: navigate to /settings/agents",
      "If not logged in: navigate to /login?next=/settings/agents",
      "Update description text to: 'Claim an AI agent you operate'",
      "Verify: Button navigates correctly based on auth state"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Show model field on agent profile pages",
    "steps": [
      "Find agent profile in frontend/app/agents/[id]/page.tsx",
      "Check if agent.model is set and not empty",
      "If set: display as metadata line near specialties",
      "Format: 'MODEL: claude-opus-4' in font-mono text-xs text-muted-foreground",
      "If not set: do not render anything for model",
      "Verify: Model displays when set",
      "Verify: Nothing shows when model is null/empty"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add edit model functionality for owned agents in settings",
    "steps": [
      "In /settings/agents page MyAgentsList component",
      "Add small 'Edit' button on each agent card",
      "Create EditAgentModal component with model input field",
      "Modal shows current model value as default",
      "On save: call PATCH /v1/agents/{id} with new model value",
      "On success: close modal, refresh agent list",
      "Verify: Human can update their agent's model from settings"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Show Human-Backed badge indicator in /agents list view",
    "steps": [
      "Open frontend/app/agents/page.tsx and find agent card component",
      "If agent.has_human_backed_badge is true: show small Shield icon (12px)",
      "Position icon next to agent name in the card",
      "Add tooltip: 'Human-backed agent'",
      "Verify: Claimed agents in /agents list show badge icon"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add USERS link to header navigation",
    "steps": [
      "Open frontend/components/header.tsx",
      "Add USERS link to desktop nav between AGENTS and API",
      "Add USERS link to mobile nav menu",
      "Link href: /users",
      "Style: font-mono text-xs tracking-wider text-muted-foreground hover:text-foreground",
      "Verify: Link visible and navigates to /users"
    ],
    "passes": true
  },
  {
    "category": "cli",
    "description": "Add claim command to CLI for agents to generate claim tokens",
    "steps": [
      "Create cli/claim.go with ClaimCmd",
      "Command name: solvr claim",
      "Read API key from config (error if not configured)",
      "Call POST /v1/agents/me/claim with API key in Authorization header",
      "Parse response: claim_url, token, expires_at, instructions",
      "Display output in clear format:",
      "  === CLAIM YOUR AGENT ===",
      "  Claim URL: {claim_url}",
      "  Token: {token}",
      "  Expires: {human readable expiry}",
      "  Give this URL to your human to link your Solvr account.",
      "Register command in cli/main.go",
      "Verify: Command generates valid claim URL when API key is configured"
    ],
    "passes": true
  },
  {
    "category": "mcp",
    "description": "Add solvr_claim tool to MCP server",
    "steps": [
      "Create mcp-server/src/tools/claim.ts",
      "Tool name: solvr_claim",
      "Tool description: Generate a claim URL for your human to link your Solvr account",
      "Parameters: none required",
      "Implementation: call POST /v1/agents/me/claim using configured API key",
      "Return object with: claim_url, token, expires_at, instructions",
      "Handle API errors gracefully with descriptive messages",
      "Register tool in mcp-server/src/index.ts",
      "Verify: Tool appears in MCP tool list",
      "Verify: Calling tool returns valid claim URL"
    ],
    "passes": true
  },
  {
    "category": "docs",
    "description": "Document agent claiming flow in API docs page",
    "steps": [
      "Open frontend/components/api/api-endpoints.tsx",
      "Add new section: 'Agent Claiming'",
      "Document POST /v1/agents/me/claim:",
      "  - Auth: API Key (agent)",
      "  - Description: Generate claim URL for human linking",
      "  - Response: { claim_url, token, expires_at, instructions }",
      "Document GET /v1/claim/{token}:",
      "  - Auth: None",
      "  - Description: Get claim info for confirmation page",
      "  - Response: { agent, token_valid, expires_at, error }",
      "Document POST /v1/claim/{token}:",
      "  - Auth: JWT (human)",
      "  - Description: Confirm claim and link agent to human",
      "  - Response: { success, agent, redirect_url, message }",
      "Add note about +50 karma bonus and Human-Backed badge",
      "Verify: Documentation is clear and complete"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add sort parameter to GET /v1/problems (votes, approaches, activity)",
    "steps": [
      "Add Sort field to PostListOptions in models/post.go",
      "Update PostsRepository.List() in db/posts.go to support ORDER BY based on sort param",
      "Support sort values: newest (default, created_at DESC), votes (vote_score DESC), approaches (approaches_count DESC)",
      "Parse sort query param in ProblemsHandler.List() in handlers/problems.go",
      "Write tests for each sort option in problems handler tests",
      "Verify: GET /v1/problems?sort=votes returns problems ordered by vote score",
      "Verify: GET /v1/problems?sort=approaches returns problems ordered by approach count",
      "Verify: GET /v1/problems with no sort defaults to newest"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add GET /v1/stats/problems endpoint with problems-specific sidebar stats",
    "steps": [
      "Add GetProblemsStats() to StatsRepository in db/stats.go",
      "Query: total problems count (type='problem', deleted_at IS NULL)",
      "Query: solved problems count (type='problem', status='solved', deleted_at IS NULL)",
      "Query: active approaches count (approaches with status IN ('in_progress','exploring') and deleted_at IS NULL on problems)",
      "Query: avg solve time in days (AVG of updated_at - created_at for solved problems)",
      "Add GetProblemsStats to StatsRepositoryInterface in handlers/stats.go",
      "Create GetProblemsStats handler in handlers/stats.go",
      "Add route GET /v1/stats/problems to router.go",
      "Response shape: { data: { total_problems, solved_count, active_approaches, avg_solve_time_days } }",
      "Write tests for handler and repository",
      "Verify: Endpoint returns correct counts from production data"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add recently-solved problems to GET /v1/stats/problems response",
    "steps": [
      "Add GetRecentlySolvedProblems(ctx, limit) to StatsRepository in db/stats.go",
      "Query: problems with status='solved', JOIN approaches to find the solver (approach author with status='succeeded' or 'verified')",
      "Include: problem id, title, solver display_name, solver type (human/agent), time_to_solve (updated_at - created_at)",
      "ORDER BY updated_at DESC, LIMIT 3",
      "Add to GetProblemsStats response: recently_solved[] array",
      "Write tests for the query",
      "Verify: Returns recently solved problems with correct solver info"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add top-solvers leaderboard to GET /v1/stats/problems response",
    "steps": [
      "Add GetTopProblemSolvers(ctx, limit) to StatsRepository in db/stats.go",
      "Query: GROUP approaches by author (author_type, author_id) WHERE approach status IN ('succeeded','verified') on non-deleted problems",
      "COUNT solved problems per author, JOIN users/agents for display_name",
      "Include: author_id, display_name, author_type (human/agent), solved_count",
      "ORDER BY solved_count DESC, LIMIT 5",
      "Add to GetProblemsStats response: top_solvers[] array",
      "Write tests for the query",
      "Verify: Returns ranked list of top problem solvers"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add getStuckProblems() and getProblemsStats() to frontend API client",
    "steps": [
      "Open frontend/lib/api.ts",
      "Add getStuckProblems(params): GET /v1/feed/stuck?page&per_page - returns feed items",
      "Add getProblemsStats(): GET /v1/stats/problems - returns problems sidebar stats",
      "Add TypeScript types for ProblemsStatsResponse in lib/api-types.ts or inline",
      "ProblemsStatsResponse: { total_problems, solved_count, active_approaches, avg_solve_time_days, recently_solved[], top_solvers[] }",
      "Verify: Methods compile and are callable"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create useProblems() hook for problems listing with pagination and filters",
    "steps": [
      "Create frontend/hooks/use-problems.ts",
      "Hook accepts: status, tags, sort, page, perPage as parameters",
      "Calls api.getPosts({ type: 'problem', status, tags, sort, page, per_page })",
      "Note: tags param needs adding to FetchPostsParams in api.ts if not present",
      "Returns: problems[], loading, error, total, hasMore, page, loadMore(), refetch()",
      "loadMore() increments page and appends results",
      "Refetches when filter params change (reset to page 1)",
      "Write Vitest tests using vi.mock for the hook",
      "Verify: Hook fetches and returns real problems data"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Replace hardcoded problems list with real API data in problems-list.tsx",
    "steps": [
      "Open frontend/components/problems/problems-list.tsx",
      "Remove the entire hardcoded problems[] array (lines 25-140)",
      "Remove the local Problem interface (lines 6-23)",
      "Import and use useProblems() hook from hooks/use-problems.ts",
      "Accept filter props from parent: status, tags, sort, searchQuery",
      "Map API PostWithAuthor data to existing card UI (preserve exact look&feel)",
      "Map fields: title, description, tags, vote_score→votes, approaches_count, author info, created_at→relative time",
      "Map weight from API (1-5 int) to display labels (critical/high/medium/low)",
      "Map status from API to existing statusConfig display",
      "Add loading skeleton state (Loader2 spinner)",
      "Add empty state when no problems returned",
      "Add error state",
      "Verify: Real problems from API display with identical look&feel to current mock"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Wire problems-filters.tsx to trigger real API calls",
    "steps": [
      "Lift filter state from problems-filters.tsx to parent problems/page.tsx",
      "Pass filter state down to both ProblemsFilters and ProblemsList as props",
      "ProblemsFilters calls onFilterChange callbacks that update parent state",
      "ProblemsList receives filter state and passes to useProblems() hook",
      "Search input: debounce 300ms, then call api.search({ q, type: 'problem' }) or pass to getPosts",
      "Status filter: maps to API status param",
      "Sort filter: maps to API sort param (newest, votes, approaches)",
      "Tags filter: maps to API tags param (comma-separated)",
      "Weight filter: needs backend support (task 23 sort covers this) or client-side filter",
      "When filters change, reset to page 1 and refetch",
      "Popular tags in filter panel: fetch from useTrending() instead of hardcoded list",
      "Verify: Changing any filter updates the problems list with matching results"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Wire problems sidebar stats to useStats() hook (replace hardcoded numbers)",
    "steps": [
      "Open frontend/components/problems/problems-sidebar.tsx",
      "Import useProblemsStats hook (or create inline fetch for /v1/stats/problems)",
      "Remove hardcoded stats array (lines 5-10)",
      "Map API response to sidebar: total_problems→TOTAL PROBLEMS, solved_count→SOLVED, active_approaches→ACTIVE APPROACHES, avg_solve_time_days→AVG. SOLVE TIME",
      "Format avg_solve_time_days as '4.2d' style",
      "Add loading state (show '—' while loading, like homepage)",
      "Verify: Sidebar shows real stats from API"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Wire sidebar NEEDS FRESH EYES section to /v1/feed/stuck endpoint",
    "steps": [
      "In problems-sidebar.tsx, remove hardcoded stuckProblems array (lines 12-31)",
      "Call api.getStuckProblems({ page: 1, per_page: 3 }) on mount",
      "Map response to existing UI: title, approaches count, days since last update",
      "Calculate daysSinceUpdate from item.created_at or updated_at",
      "Make items clickable: Link to /problems/{id}",
      "Make VIEW ALL STUCK PROBLEMS button navigate to /problems?status=stuck or apply filter",
      "Add loading and empty states",
      "Verify: Shows real stuck problems from API"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Wire sidebar RECENTLY SOLVED and TOP SOLVERS to /v1/stats/problems",
    "steps": [
      "In problems-sidebar.tsx, remove hardcoded recentlySolved array (lines 33-52)",
      "Remove hardcoded topSolvers array (lines 54-60)",
      "Fetch from api.getProblemsStats() which returns recently_solved[] and top_solvers[]",
      "RECENTLY SOLVED: map solver.name, solver.type (human/ai icon), time_to_solve",
      "Make items clickable: Link to /problems/{id}",
      "TOP SOLVERS: map name, type (human/ai icon), solved_count, optionally streak if API provides",
      "Make solver names link to /users/{id} or /agents/{id} based on type",
      "Add loading and empty states for both sections",
      "Verify: Shows real recently solved and top solver data"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Wire sidebar TRENDING TAGS to useTrending() hook",
    "steps": [
      "In problems-sidebar.tsx, remove hardcoded hotTags array (lines 62-69)",
      "Import useTrending from hooks/use-stats",
      "Map trending.tags to existing tag buttons: name→tag text, count→count display",
      "Make tag buttons clickable: clicking a tag applies it as a filter (pass callback to parent)",
      "Add loading state",
      "Verify: Shows real trending tags with counts from API"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Make all /problems page buttons functional (POST A PROBLEM, LOAD MORE, CTAs)",
    "steps": [
      "POST A PROBLEM button (desktop header + mobile fixed): navigate to /problems/new if authenticated, /login?next=/problems/new if not",
      "Create frontend/app/problems/new/page.tsx with problem creation form",
      "Form fields: title, description, tags (multi-select), success_criteria (list input), weight (1-5 select)",
      "On submit: call api.createPost({ type: 'problem', ...fields })",
      "On success: redirect to /problems/{new_id}",
      "LOAD MORE button in problems-list.tsx: call loadMore() from useProblems hook, show loading spinner, hide when !hasMore",
      "BROWSE OPEN PROBLEMS sidebar CTA: apply status=open filter or navigate to /problems?status=open",
      "Verify: All buttons trigger correct actions"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add GET /v1/sitemap/counts endpoint returning indexable content counts per type",
    "steps": [
      "Add SitemapCounts struct to models/sitemap.go with Posts, Agents, Users int fields",
      "Add GetSitemapCounts(ctx) to SitemapRepository in db/sitemap.go with 3 COUNT queries (same WHERE filters as existing)",
      "Add GetSitemapCounts to SitemapRepositoryInterface in handlers/sitemap.go",
      "Add GetSitemapCounts handler returning { data: { posts: N, agents: N, users: N } }",
      "Add route GET /v1/sitemap/counts to router.go inside the existing sitemap block",
      "Update MockSitemapRepository in sitemap_test.go to implement GetSitemapCounts",
      "Write tests: correct counts, empty DB zeros, repo error 500",
      "Verify: go test ./internal/api/handlers/ passes"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add pagination to GET /v1/sitemap/urls with type, page, per_page query params",
    "steps": [
      "Add SitemapURLsOptions struct to models/sitemap.go (Type string, Page int, PerPage int)",
      "Add GetPaginatedSitemapURLs(ctx, opts) to SitemapRepository in db/sitemap.go with LIMIT/OFFSET queries",
      "Add GetPaginatedSitemapURLs to SitemapRepositoryInterface",
      "Define SitemapMaxPerPage=5000 and SitemapDefaultPerPage=5000 constants in handlers/sitemap.go",
      "Update GetSitemapURLs handler: if type param present, parse type/page/per_page and use paginated path; if absent, fall back to existing behavior (backward compat)",
      "Validate type is posts/agents/users (400 on invalid), per_page <= 5000, page >= 1",
      "Response shape stays identical: { data: { posts: [], agents: [], users: [] } } with only relevant array populated",
      "Update MockSitemapRepository in sitemap_test.go to implement GetPaginatedSitemapURLs",
      "Write tests: type=posts returns only posts, pagination offset works, invalid type 400, no type param backward compat",
      "Verify: go test ./internal/api/handlers/ passes"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add getSitemapCounts() and paginated getSitemapUrls() params to API client",
    "steps": [
      "Add APISitemapCountsResponse type to api-types.ts: { data: { posts: number, agents: number, users: number } }",
      "Add getSitemapCounts() method to SolvrAPI class calling GET /v1/sitemap/counts",
      "Update getSitemapUrls() to accept optional { type?: string, page?: number, per_page?: number }",
      "Build query string from params, append to /v1/sitemap/urls when provided",
      "Existing getSitemapUrls() with no params still works (backward compat)",
      "Verify: npx tsc --noEmit passes"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add sort parameter to GET /v1/questions",
    "steps": [
      "In questions.go List handler, parse sort query param after tags parsing (line ~167)",
      "Valid sort values: newest (default), votes, answers",
      "Map to PostListOptions.Sort (field already exists in models/post.go)",
      "Follow same pattern as problems.go lines 177-184",
      "Add 'answers' sort support in db/posts.go List() ORDER BY clause if not present",
      "Write tests for each sort option in questions handler tests",
      "Verify: GET /v1/questions?sort=votes returns questions ordered by vote score",
      "Verify: GET /v1/questions?sort=answers returns questions ordered by answer count",
      "Verify: Invalid sort values silently default to newest"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Set question status to 'answered' when first answer is created (enable ANSWERED filter)",
    "steps": [
      "PostStatusAnswered ('answered') is declared in models/post.go line 36 and valid for questions (line 173), but no code ever sets it",
      "Currently CreateAnswer in db/answers.go:145 only inserts the answer — does NOT update question status",
      "AcceptAnswer in db/answers.go:319 jumps open→solved, skipping answered entirely",
      "In AnswersRepository.CreateAnswer (db/answers.go): after inserting the answer, UPDATE the question status from 'open' to 'answered' if current status is 'open'",
      "SQL: UPDATE posts SET status = 'answered', updated_at = NOW() WHERE id = $1 AND type = 'question' AND status = 'open'",
      "This makes the lifecycle: open → answered (first answer) → solved (answer accepted)",
      "The WHERE status = 'open' guard ensures we don't overwrite 'solved' if answer was already accepted",
      "Write test: create question (open), add answer → question status becomes 'answered'",
      "Write test: question with accepted answer (solved), add another answer → status stays 'solved'",
      "Verify: GET /v1/questions?status=answered now returns questions that have answers but no accepted answer"
    ],
    "passes": true
  },
  {
    "category": "backend",
    "description": "Add GET /v1/stats/questions endpoint for sidebar dashboard",
    "steps": [
      "Add to StatsRepositoryInterface in handlers/stats.go: GetQuestionsStats, GetRecentlyAnsweredQuestions, GetTopAnswerers",
      "Note: GetQuestionsAnsweredCount() already exists in db/stats.go (lines 92-103) — reuse/reference for answered_count",
      "Implement GetQuestionsStats in db/stats.go: total_questions (COUNT type='question' AND deleted_at IS NULL), answered_count (COUNT where accepted_answer_id IS NOT NULL, reuse existing pattern), response_rate (answered/total * 100), avg_response_time_hours (AVG time from question created_at to first answer created_at via JOIN answers ON question_id)",
      "Implement GetRecentlyAnsweredQuestions(ctx, limit): questions recently answered/solved with answerer display_name and type, ORDER BY updated_at DESC",
      "Implement GetTopAnswerers(ctx, limit): GROUP answers by author, COUNT per author, JOIN users/agents for display_name, include accept_rate (accepted/total * 100), ORDER BY count DESC",
      "Add GetQuestionsStats handler to handlers/stats.go (follow GetProblemsStats pattern at lines 188-221)",
      "Response: { data: { total_questions, answered_count, response_rate, avg_response_time_hours, recently_answered[], top_answerers[] } }",
      "Add route: r.Get('/stats/questions', statsHandler.GetQuestionsStats) in router.go after line 339",
      "Write handler and repository tests",
      "Verify: Returns correct JSON with all fields populated from production data"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add FetchQuestionsParams, APIQuestionsStatsResponse types and getQuestions/getQuestionsStats methods",
    "steps": [
      "Add FetchQuestionsParams to api-types.ts: { status?: string, tags?: string[], sort?: 'newest'|'votes'|'answers', page?: number, per_page?: number }",
      "Add APIQuestionsStatsResponse to api-types.ts following APIProblemsStatsResponse pattern",
      "Fields: total_questions, answered_count, response_rate (number), avg_response_time_hours (number), recently_answered: Array<{ id, title, answerer_name, answerer_type, time_to_answer_hours }>, top_answerers: Array<{ author_id, display_name, author_type, answer_count, accept_rate }>",
      "Add getQuestions(params?: FetchQuestionsParams) method to api.ts → GET /v1/questions with query params (follow getProblems pattern)",
      "Add getQuestionsStats() method to api.ts → GET /v1/stats/questions (follow getProblemsStats pattern)",
      "Verify: npx tsc --noEmit passes with no type errors"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create useQuestions hook following useProblems pattern",
    "steps": [
      "Create frontend/hooks/use-questions.ts following hooks/use-problems.ts pattern exactly",
      "Accept options: { status?, tags?, sort?, page?, perPage? }",
      "Call api.getQuestions(params) on mount and when options change",
      "Return: questions[], loading, error, total, hasMore, page, refetch, loadMore",
      "Transform API PostWithAuthor to QuestionListItem: id, title, snippet (description truncated 200 chars), status, displayStatus, voteScore, answersCount, author (id, name, type), tags, timestamp (formatRelativeTime), acceptedAnswer info",
      "Map backend statuses to display: open→unanswered, answered→answered, solved→accepted",
      "loadMore() increments page and appends, filter change resets to page 1",
      "Verify: Hook compiles and returns typed data"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Replace mock data in questions-list.tsx with useQuestions hook",
    "steps": [
      "Accept props: status?, sort?, tags? (same pattern as ProblemsList)",
      "Remove hardcoded Question interface and questions[] array (lines 6-101)",
      "Import and use useQuestions({ status, sort, tags }) hook",
      "Keep exact same card layout, styling, status badges (AWAITING/ANSWERED/ACCEPTED via statusConfig)",
      "Map hook data to existing UI: title, preview→snippet, votes→voteScore, answersCount, author, tags, createdAt→timestamp",
      "Add loading state with spinner or skeleton",
      "Add error state",
      "Add empty state when no questions found",
      "Wire LOAD MORE button to loadMore() from hook, hide when !hasMore",
      "Show loading spinner on LOAD MORE button while fetching next page",
      "Verify: Renders real questions from API with identical gorgeous look"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Connect questions-filters.tsx to page state like problems-filters pattern",
    "steps": [
      "Make questions/page.tsx a 'use client' component with useState for status, sort, tags (copy problems/page.tsx pattern exactly)",
      "Add useRouter and useAuth imports for ASK QUESTION button",
      "Pass filter state and setter callbacks as props to QuestionsFilters: status, sort, tags, onStatusChange, onSortChange, onTagsChange",
      "Update QuestionsFilters to accept and use these props instead of internal useState",
      "Map filter UI values to API params: UNANSWERED→status=open, ANSWERED→status=answered, ACCEPTED→status=solved",
      "Pass status, sort, tags as props to QuestionsList",
      "Keep same gorgeous filter UI: status pills, sort buttons, tag pills, search input",
      "Keep search input as local state for future use",
      "Verify: Changing any filter triggers QuestionsList refetch via useQuestions hook"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create useQuestionsStats hook following useProblemsStats pattern",
    "steps": [
      "Create frontend/hooks/use-questions-stats.ts following hooks/use-problems-stats.ts exactly",
      "Call api.getQuestionsStats() on mount",
      "Return: { stats: QuestionsStatsData | null, loading, error, refetch }",
      "QuestionsStatsData includes: total_questions, answered_count, response_rate, avg_response_time_hours, recently_answered[], top_answerers[]",
      "Verify: Hook compiles and returns typed data"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Replace all mock data in questions-sidebar.tsx with real API calls",
    "steps": [
      "Add 'use client' directive, import useQuestionsStats, useTrending, useState, useEffect, api, Link",
      "Accept onTagClick prop (same as ProblemsSidebar)",
      "Replace hardcoded stats[] with useQuestionsStats: TOTAL QUESTIONS, ANSWERED, RESPONSE RATE (format as X.X%), AVG. RESPONSE (format as Xh or Xmin)",
      "Replace hardcoded unansweredQuestions[] with useEffect calling api.getQuestions({ status: 'open', sort: 'votes', per_page: 3 })",
      "Replace hardcoded hotQuestions[] with useEffect calling api.getQuestions({ sort: 'votes', per_page: 3 })",
      "Replace hardcoded topAnswerers[] with data from useQuestionsStats → top_answerers",
      "Replace hardcoded trendingTags[] with useTrending() hook (reuse existing from hooks/use-stats.ts)",
      "Add loading states for each section matching problems-sidebar.tsx pattern",
      "Add empty states for each section",
      "Keep exact same card designs, icons (HelpCircle, Zap, Trophy, etc.), and styling",
      "Wire VIEW ALL UNANSWERED → Link to /questions?status=open",
      "Wire ASK THE COLLECTIVE → Link to /questions/new",
      "Wire tag buttons to onTagClick prop callback",
      "Verify: All 6 sidebar sections show real data with same gorgeous look and feel"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create /questions/new page reusing NewPostForm component",
    "steps": [
      "Create frontend/app/questions/new/page.tsx",
      "Follow exact pattern of frontend/app/problems/new/page.tsx",
      "Import Header and NewPostForm components",
      "Use NewPostForm with defaultType='question' (component already supports question type)",
      "Page header: 'NEW QUESTION' mono subtitle, 'Ask a Question' h1 title",
      "Add metadata export: title='Ask a Question — Solvr', description='Ask the collective a question'",
      "Verify: Page renders, form submits via POST /v1/posts with type=question, redirects to /questions/{new_id}"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Wire ASK QUESTION button on questions page with auth check and mobile CTA",
    "steps": [
      "In questions/page.tsx (now a client component from task 6), add handleAskQuestion function",
      "handleAskQuestion: if isAuthenticated → router.push('/questions/new'), else → router.push('/login?next=/questions/new')",
      "Wire onClick on desktop ASK QUESTION button in page header",
      "Add mobile fixed CTA button at bottom: md:hidden fixed bottom-6 left-6 right-6 (same pattern as problems page POST A PROBLEM button)",
      "Mobile button text: ASK QUESTION, same styling as problems mobile CTA",
      "Verify: Desktop button works with auth check",
      "Verify: Mobile CTA visible on small screens with auth check"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Wire vote buttons in question-content.tsx and answers-list.tsx using existing useVote hook",
    "steps": [
      "In question-content.tsx: import useVote from hooks/use-vote.ts",
      "Initialize useVote(question.id, question.voteScore) — note: question is a post, voteOnPost works",
      "Wire ThumbsUp onClick to upvote(), ThumbsDown onClick to downvote()",
      "Display score from useVote hook instead of static question.voteScore",
      "Add active state styling: emerald bg when userVote='up', red bg when userVote='down'",
      "In answers-list.tsx: useVote calls api.voteOnPost which may not work for answers — check if POST /v1/answers/:id/vote uses same path, if not create a small useAnswerVote wrapper calling api.voteOnAnswer",
      "Add api.voteOnAnswer(answerId, direction) to api.ts if needed → POST /v1/answers/{id}/vote",
      "Wire each answer's vote buttons to its own vote hook instance",
      "Show login prompt or error toast on 401 vote failure",
      "Verify: Clicking vote buttons calls API, score updates optimistically, reverts on error"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Wire remaining dead buttons and navigation on questions page",
    "steps": [
      "question-header.tsx: wire Share button (Share2 icon, line 76) to navigator.clipboard.writeText(window.location.href) with toast confirmation",
      "question-header.tsx: wire Bookmark button (line 80) to bookmark API or local state",
      "question-content.tsx: wire Flag button (line 47) to open ReportModal with targetType='post'",
      "Note: answers-list.tsx Flag/Report is ALREADY wired to ReportModal — no work needed there",
      "Sidebar NEEDS YOUR KNOWLEDGE items: ensure each wraps in Link to /questions/{id}",
      "Sidebar HOT THIS WEEK items: ensure each wraps in Link to /questions/{id}",
      "Questions list cards: ensure each links to /questions/{id} using real IDs from API",
      "Sidebar tag buttons: wire to onTagClick prop so clicking adds tag to active filters",
      "Verify: Every single clickable element on /questions and /questions/[id] does something meaningful"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Replace custom api-footer.tsx with shared Footer component for consistency with rest of site",
    "steps": [
      "In app/api-docs/page.tsx: replace <ApiFooter /> with shared <Footer /> from components/footer.tsx",
      "The shared Footer already has: Platform links, Developer links (API Docs, MCP, Agent Registration, Developer Portal, Status), Company links (Terms, Privacy, About, Blog), brand credits",
      "Move the GET STARTED CTA (Get API Key + Explore buttons) from api-footer into a new section ABOVE the footer, still within the api-docs page layout",
      "Move the Resources section (OpenAPI Spec, GitHub, Guides links) into the same CTA section above footer",
      "Remove api-footer.tsx import from api-docs/page.tsx",
      "Verify: Footer on /api-docs now matches footer on homepage, /problems, /questions, etc.",
      "Verify: CTA section with Get API Key and resources still visible above footer"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add missing solvr_claim tool to api-mcp.tsx MCP tools list",
    "steps": [
      "In api-mcp.tsx: add 5th tool to mcpTools array after solvr_answer",
      "Tool: { name: 'solvr_claim', description: 'Generate a claim token for your human to link your Solvr account to this agent', params: '(none)' }",
      "Reference: actual tool definition in mcp-server/src/tools.ts (solvr_claim tool)",
      "Verify: MCP docs section now shows 5 tools matching actual MCP server"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add all undocumented public API endpoints to api-docs endpoint data files",
    "steps": [
      "In api-endpoint-data-core.ts Agents group: add GET /agents (list all agents with pagination), PATCH /agents/{id} (update agent profile), GET /agents/{id}/activity (agent activity feed)",
      "In api-endpoint-data-core.ts Stats group: add GET /stats/problems (problems dashboard stats), GET /stats/ideas (ideas dashboard stats), GET /stats/questions (questions dashboard stats — once backend task creates it)",
      "In api-endpoint-data-core.ts add new Sitemap group: GET /sitemap/urls (all indexable URLs for sitemap generation), GET /sitemap/counts (indexable content counts per type) — both exist in router.go lines 342-349",
      "In api-endpoint-data-content.ts Problems group: add POST /problems (create problem, auth required), GET /problems/{id}/export (export as markdown)",
      "In api-endpoint-data-content.ts Problems group: add POST /approaches/{id}/progress (add progress note to approach)",
      "In api-endpoint-data-content.ts Questions group: add POST /questions (create question, auth required)",
      "In api-endpoint-data-content.ts Ideas group: add POST /ideas (create idea, auth required)",
      "In api-endpoint-data-user.ts Current User group: add PATCH /me (update own profile), GET /me/posts (list own posts), GET /me/contributions (list own contributions)",
      "In api-endpoint-data-user.ts Users group: add GET /users (list all users with pagination), GET /users/{id}/agents (list user's claimed agents)",
      "For each endpoint: include method, path, description, auth requirement, params, and example response",
      "Follow exact same EndpointGroup structure as existing entries",
      "Reference router.go and corresponding handler files for accurate params and responses",
      "Verify: All public API endpoints in router.go are now documented"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Fix hero copy button to copy base URL, and wire status indicators to real health check",
    "steps": [
      "In api-hero.tsx line 10: change copyApiKey to copy 'https://api.solvr.dev/v1' (the displayed URL) instead of 'solvr_sk_xxxxxxxxxxxxx'",
      "In api-mcp.tsx lines 211-214: replace hardcoded 'ONLINE' badge with real health check",
      "Create a simple useApiHealth hook or inline fetch to GET https://api.solvr.dev/v1/health on mount",
      "If health check succeeds: show green dot + 'ONLINE', if fails: show red dot + 'OFFLINE'",
      "Hero stats (18ms, 99.9%, 60/min) can remain static for now — these are marketing/aspirational values",
      "Verify: Copy button copies the base URL, MCP status reflects real API health"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Ensure status indicator is handled correctly when api-footer is replaced with shared Footer",
    "steps": [
      "Note: This is a dependency of Task 13 (footer replacement)",
      "When replacing api-footer with shared Footer, the hardcoded 'ALL SYSTEMS OPERATIONAL' (line 98-111) goes away automatically",
      "The shared Footer already links to /status page with a pulsing green dot indicator",
      "If /status page doesn't exist yet, create a simple redirect or placeholder",
      "Check if status.solvr.dev external link should be kept somewhere (currently in api-footer line 107)",
      "Verify: No hardcoded status claims remain on /api-docs page (except MCP ONLINE handled by Task 16)"
    ],
    "passes": false
  }
]
